File Path: amplify/backend.ts
/**
 * Backend Configuration
 * ---------------------
 * This module defines and configures the backend for the application using AWS Amplify.
 * It integrates authentication, data resources, and user management functions into the backend.
 */

import { defineBackend } from '@aws-amplify/backend'; // Amplify backend configuration utility
import { auth } from './auth/resource'; // Authentication configuration module
import { data } from './data/resource'; // Data resource configuration module
import { manageUsers } from './functions/manage-users/resource'; // User management function module

/**
 * Sets up the backend by integrating the authentication, data, and user management functions.
 * 
 * @remarks
 * This function call initializes the backend for the application with the necessary resources
 * for authentication, data management, and user administration.
 * 
 * @returns {void} This function does not return a value.
 */
defineBackend({
  auth, // Auth resource setup
  data, // Data resource setup
  manageUsers, // User management functionality
});

/**
 * (Optional) Backend Setup with AWS SES Email Configuration
 * ---------------------------------------------------------
 * This commented section includes optional setup to integrate AWS SES for production email 
 * using an Email Identity. Uncomment and configure as needed.
 */
/*
import { Stack } from "aws-cdk-lib/core"; // AWS CDK core library
import { EmailIdentity } from "aws-cdk-lib/aws-ses"; // AWS SES Email Identity utility

// Define the backend configuration, including email identity for SES
const backend = defineBackend({
  auth,
  data,
  manageUsers,
});

// Configure the SES email identity for the user pool
const { cfnUserPool } = backend.auth.resources.cfnResources;
const authStack = Stack.of(cfnUserPool);

// Retrieve the email identity from SES based on environment variables or fallback
const email = EmailIdentity.fromEmailIdentityName(
  authStack,
  "EmailIdentity",
  process.env.EMAIL || '' // Email address to be used for SES
);

// Set the email configuration for the Cognito user pool
cfnUserPool.emailConfiguration = {
  emailSendingAccount: "DEVELOPER",
  sourceArn: email.emailIdentityArn, // ARN for the SES Email Identity
};
*/

---
File Path: amplify/auth/resource.ts
/**
 * Authentication Resource Configuration
 * -------------------------------------
 * This module configures the authentication resource for the application using AWS Amplify Gen 2.
 * It enables email-based login with customizable verification emails and specifies required 
 * user attributes for registration. The module also defines user groups and access permissions 
 * for managing users within the application.
 */

import { defineAuth } from '@aws-amplify/backend'; // AWS Amplify backend utility for authentication
import { manageUsers } from '../functions/manage-users/resource'; // User management function

/**
 * Configures the authentication setup, including email-based login, user attributes, user groups,
 * and access permissions for user management operations.
 * 
 * @remarks
 * This configuration uses email as the login method and customizes the verification email sent to users.
 * It also defines required user attributes and creates an admin group for authorization purposes.
 * The `manage-users` function is granted permissions to interact with the user pool.
 * 
 * @constant
 * @type {ReturnType<typeof defineAuth>}
 */
export const auth = defineAuth({
  loginWith: {
    email: {
      verificationEmailStyle: "CODE", // Specifies verification method as a code.
      verificationEmailSubject: "Welcome to Meet A Drifter", // Custom subject for the verification email.
      /**
       * Generates a custom body for the verification email.
       * 
       * @param createCode - A function that generates a unique verification code.
       * @returns {string} The complete verification email content with the generated code.
       */
      verificationEmailBody: (createCode: () => string) =>
        `Use this code to confirm your Meet A Drifter account: ${createCode()}`,
    },
  },
  userAttributes: {
    familyName: {
      required: true, // Family name (lastName) is a required field for user registration.
    },
    givenName: {
      required: true, // Given name (firstName) is a required field for user registration.
    },
    preferredUsername: {
      required: true, // Preferred username is required for user registration.
    },
  },
  groups: ['admin'], // Defines the 'admin' user group for authorization purposes.

  /**
   * Grants permissions for the `manage-users` function to perform actions on Cognito.
   * 
   * @param allow - A utility to specify allowed actions on the `manageUsers` function.
   * @returns {Array} The list of allowed actions for managing users and user groups.
   */
  access: (allow) => [
    allow.resource(manageUsers).to([
      "listUsers", // Permission to list all users.
      "listGroupsForUser", // Permission to list groups for a specific user.
      "addUserToGroup", // Permission to add a user to a group.
      "removeUserFromGroup", // Permission to remove a user from a group.
    ]),
  ],
});

---
File Path: amplify/functions/manage-users/resource.ts
import { defineFunction } from "@aws-amplify/backend";

/**
 * Amplify Function: manage-users
 * ------------------------------
 * This function handles user management tasks within the application, utilizing AWS Cognito APIs
 * to interact with the user pool for various operations, such as listing users, managing groups, 
 * and updating user information.
 * 
 * @remarks
 * This function can be extended with additional capabilities like custom authentication flows
 * or more complex group management if needed.
 * 
 * @constant
 * @type {ReturnType<typeof defineFunction>}
 */
export const manageUsers = defineFunction({
  /**
   * Unique name for the function.
   * 
   * @remarks
   * This name will be used for AWS resource generation and must be unique within the Amplify project.
   * 
   * @type {string}
   */
  name: "manage-users",

  /**
   * Entry point for the function handler.
   * 
   * @remarks
   * The default entry is 'handler.ts' in the same directory as this file, but can be customized 
   * to point to a different handler if required.
   * 
   * @type {string}
   */
  entry: "./handler.ts",

  /**
   * Optional configuration for the function.
   * 
   * @remarks
   * You can specify function-specific settings, such as memory allocation, timeout limits,
   * and environment variables. Adjust these settings based on the expected usage and 
   * requirements of the function.
   * 
   * @example
   * {
   *   timeoutSeconds: 30, // Sets the function timeout to 30 seconds.
   *   memoryMB: 512, // Allocates 512MB of memory for the function.
   * }
   * 
   * @type {object}
   * @property {number} [timeoutSeconds] - Optional timeout in seconds for the function execution.
   * @property {number} [memoryMB] - Optional memory allocation in megabytes.
   */
  // Add configuration options here if needed, such as:
  // timeoutSeconds: 30,
  // memoryMB: 512,
});

---
File Path: amplify/functions/manage-users/handler.ts
/**
 * File: amplify/functions/manage-users/resource.ts
 * 
 * Description:
 * -------------
 * This file defines the `manage-users` function that handles user management tasks
 * in the application, such as listing users and their groups, adding users to groups,
 * and removing users from groups. It uses AWS Cognito to interact with the user pool
 * and execute these actions.
 * 
 * The function is invoked through AppSync and operates based on the event's `fieldName`.
 */

import {
  CognitoIdentityProviderClient,
  ListUsersCommand,
  AdminListGroupsForUserCommand,
  AdminAddUserToGroupCommand,
  AdminRemoveUserFromGroupCommand,
  UserType,
  GroupType,
} from '@aws-sdk/client-cognito-identity-provider';
import { env } from '$amplify/env/manage-users';
import { AppSyncIdentityIAM, AppSyncIdentityCognito, AppSyncIdentityOIDC } from 'aws-lambda';

/**
 * Interface for the arguments passed to the manage-users function.
 * These arguments define the username and groupName, both of which are optional and vary 
 * depending on the operation (e.g., adding/removing users from groups).
 */
interface ManageUsersArguments {
  username?: string;
  groupName?: string;
}

/**
 * Interface representing a user along with their associated groups.
 * Extends the `UserType` from Cognito with a mandatory `Username` field and includes 
 * an array of groups.
 */
interface UserWithGroups {
  user: UserType & { Username: string };
  groups: GroupType[];
}

/**
 * Custom AppSync event structure.
 * Defines the structure of the event passed to the function when triggered via AppSync.
 * 
 * @template T - The type of the arguments passed in the event.
 */
interface CustomAppSyncResolverEvent<T> {
  fieldName: string;
  arguments: T;
  identity?: AppSyncIdentityIAM | AppSyncIdentityCognito | AppSyncIdentityOIDC;
  request?: {
    headers: Record<string, string>;
    domainName: string | null;
  };
  source?: Record<string, unknown> | null;
}

/**
 * Handler function for managing users.
 * 
 * @remarks
 * This function processes user management operations such as listing users and their associated
 * groups, adding users to specific groups, and removing users from groups in AWS Cognito.
 * The specific action is determined by the `fieldName` provided in the event.
 * 
 * @param event - The AppSync event, including the operation field and the necessary arguments.
 * 
 * @returns {Promise<UserWithGroups[] | string>} The result of the user management operation, 
 * either a list of users with their groups or a success message.
 * 
 * @throws {Error} If the `fieldName` is missing or invalid, or if an error occurs during the operation.
 */
export const handler = async (event: CustomAppSyncResolverEvent<ManageUsersArguments>): Promise<UserWithGroups[] | string> => {
  console.log('Received event:', JSON.stringify(event, null, 2));

  // Initialize the Cognito client
  const cognitoClient = new CognitoIdentityProviderClient({});
  const fieldName = event.fieldName;

  if (!fieldName) {
    throw new Error('Cannot determine the field name from the event.');
  }

  try {
    switch (fieldName) {
      case 'listUsersAndGroups':
        // List all users in the user pool
        const listUsersCommand = new ListUsersCommand({
          UserPoolId: env.AMPLIFY_AUTH_USERPOOL_ID,
        });
        const usersResponse = await cognitoClient.send(listUsersCommand);
        const users: UserType[] = usersResponse.Users || [];

        // Filter users with valid usernames
        const validUsers: (UserType & { Username: string })[] = users.filter(
          (user): user is UserType & { Username: string } => !!user.Username
        );

        // Retrieve groups for each user
        const usersWithGroups: UserWithGroups[] = await Promise.all(
          validUsers.map(async (user) => {
            const listGroupsCommand = new AdminListGroupsForUserCommand({
              UserPoolId: env.AMPLIFY_AUTH_USERPOOL_ID,
              Username: user.Username,
            });
            const groupsResponse = await cognitoClient.send(listGroupsCommand);
            const groups: GroupType[] = groupsResponse.Groups
              ? groupsResponse.Groups.filter(
                  (group): group is GroupType & { GroupName: string } => !!group.GroupName
                )
              : [];
            return {
              user,
              groups,
            };
          })
        );

        // Return users with their groups
        return usersWithGroups;

      case 'addUserToGroup':
        const { username: addUsername, groupName: addGroupName } = event.arguments;

        if (!addUsername || !addGroupName) {
          throw new Error("Missing 'username' or 'groupName' parameter");
        }

        const addCommand = new AdminAddUserToGroupCommand({
          UserPoolId: env.AMPLIFY_AUTH_USERPOOL_ID,
          Username: addUsername,
          GroupName: addGroupName,
        });
        await cognitoClient.send(addCommand);

        return `User ${addUsername} added to group ${addGroupName}`;

      case 'removeUserFromGroup':
        const { username: removeUsername, groupName: removeGroupName } = event.arguments;

        if (!removeUsername || !removeGroupName) {
          throw new Error("Missing 'username' or 'groupName' parameter");
        }

        const removeCommand = new AdminRemoveUserFromGroupCommand({
          UserPoolId: env.AMPLIFY_AUTH_USERPOOL_ID,
          Username: removeUsername,
          GroupName: removeGroupName,
        });
        await cognitoClient.send(removeCommand);

        return `User ${removeUsername} removed from group ${removeGroupName}`;

      default:
        throw new Error('Invalid action parameter');
    }
  } catch (error) {
    console.error('Error in manage-users function:', error);
    throw error;
  }
};

---
File Path: amplify/data/resource.ts
/**
 * File Path: amplify/data/resource.ts
 * 
 * Data Resource Configuration
 * ---------------------------
 * This file defines the data models and their configuration for the application using AWS Amplify Gen 2.
 * It sets up the schema for the following models: 
 * - `Poll`: Manages polls with options, status, and creation timestamp.
 * - `Vote`: Records votes linked to polls and users.
 * - `SiteNotification`: Stores notifications to be displayed to users.
 * - `LessonContent`: Stores content such as code, setup instructions, or prerequisites, with ordering capabilities.
 * 
 * Additionally, custom queries and mutations for user management tasks such as listing users, adding users to groups,
 * and removing users from groups are implemented with proper authorization.
 */

import { type ClientSchema, a, defineData } from '@aws-amplify/backend'; // AWS Amplify types and functions import
import { manageUsers } from '../functions/manage-users/resource'; // Import the manageUsers function for custom queries/mutations

/**
 * Schema Definition
 * -----------------
 * Defines the data models used in the application and their authorization rules.
 * These models define the structure for polls, votes, notifications, and lesson content.
 */
const schema = a.schema({
  // Custom Link type for use in lesson content
  Link: a.customType({
    text: a.string(), // Display text for the link
    url: a.string(),  // URL the link points to
  }),

  // Poll model definition
  Poll: a.model({
    title: a.string().required(),  // Poll title
    options: a.string().array().required(), // List of options for the poll
    createdAt: a.datetime().required(), // Poll creation timestamp
    status: a.string().required(), // Status of the poll (e.g., active, closed)
  }).authorization((allow) => [
    allow.group('admin').to(['create', 'update', 'delete']), // Admins can create, update, and delete
    allow.authenticated('userPools').to(['read']), // Authenticated users can read
  ]),

  // Vote model definition
  Vote: a.model({
    pollId: a.id().required(),  // ID of the poll being voted on
    userId: a.string().required(),  // ID of the user casting the vote
    option: a.string().required(),  // The selected poll option
  }).authorization((allow) => [
    allow.authenticated('userPools').to(['create', 'read']), // Authenticated users can create votes and read
  ]),

  // SiteNotification model definition
  SiteNotification: a.model({
    message: a.string().required(), // Notification message
  }).authorization((allow) => [
    allow.authenticated('userPools').to(['read']), // Authenticated users can read notifications
    allow.group('admin').to(['create', 'update', 'delete', 'read']), // Admins have full access
  ]),

  // LessonContent model definition for managing content
  LessonContent: a.model({
    type: a.string().required(), // Content type (e.g., "code", "setup", or "prereq")
    title: a.string().required(), // Title of the content
    slug: a.string().required(), // Unique slug for dynamic routing
    code: a.string(), // Optional code content (if applicable)
    docs: a.string().required(), // Documentation for the content
    links: a.ref('Link').array(), // Array of associated links
    isOrdered: a.boolean().required().default(false), // Flag indicating if this content is part of a lesson order
    orderIndex: a.integer(), // Position in the lesson order (if applicable)
  }).authorization((allow) => [
    allow.authenticated('userPools').to(['read']), // Authenticated users can read lesson content
    allow.group('admin').to(['create', 'update', 'delete', 'read']), // Admins have full access
  ]),

  // Custom Queries and Mutations for User Management
  listUsersAndGroups: a
    .query()
    .authorization((allow) => [allow.group('admin')]) // Only admins can list users and groups
    .handler(a.handler.function(manageUsers)) // Links to the manageUsers function
    .returns(a.json()), // Returns JSON data

  addUserToGroup: a
    .mutation()
    .arguments({
      username: a.string().required(),  // Username of the user to be added to the group
      groupName: a.string().required(), // Name of the group to which the user will be added
    })
    .authorization((allow) => [allow.group('admin')]) // Only admins can add users to groups
    .handler(a.handler.function(manageUsers)) // Links to the manageUsers function
    .returns(a.string()), // Returns a success message

  removeUserFromGroup: a
    .mutation()
    .arguments({
      username: a.string().required(),  // Username of the user to be removed from the group
      groupName: a.string().required(), // Name of the group from which the user will be removed
    })
    .authorization((allow) => [allow.group('admin')]) // Only admins can remove users from groups
    .handler(a.handler.function(manageUsers)) // Links to the manageUsers function
    .returns(a.string()), // Returns a success message
});

/**
 * Schema Type Definition
 * ----------------------
 * Defines the schema type for use across the application.
 * This type is inferred from the schema object, ensuring consistency in the data models.
 */
export type Schema = ClientSchema<typeof schema>;

/**
 * Data Configuration
 * ------------------
 * Configures the data layer for the application, including schema and authorization modes.
 * The default authorization mode is `userPool`, which ensures that authenticated users
 * from the user pool can interact with the data models based on the authorization rules.
 */
export const data = defineData({
  schema, // The defined schema
  authorizationModes: {
    defaultAuthorizationMode: 'userPool', // Default authorization mode
  },
});

---
File Path: app/fonts.ts
/**
 * File Path: app/fonts.ts
 * 
 * Font Configuration
 * ------------------
 * This module configures the Google fonts used throughout the application. It sets up fonts such as
 * 'Inter', 'Josefin Slab', 'Climate Crisis', and 'Tilt Warp' with specific subsets and display settings.
 * These fonts are imported and configured using the Next.js font API for efficient loading and usage.
 */

import { Inter, Josefin_Slab, Climate_Crisis, Tilt_Warp } from 'next/font/google';  // Import Google fonts using the Next.js font API.

/**
 * Configuration for the 'Inter' font.
 * 
 * @remarks
 * The 'Inter' font is set up to include the 'latin' subset, making it suitable for texts using the Latin script.
 * The 'display' property is set to 'swap' to ensure that text is displayed immediately with a fallback font,
 * then swapped with the custom font once it's loaded. This improves perceived performance and user experience.
 * 
 * @returns {ReturnType<typeof Inter>} The configured 'Inter' font.
 */
export const inter = Inter({
  subsets: ['latin'],  // Includes the Latin character set for broad compatibility.
  display: 'swap',     // Uses 'swap' to ensure text remains visible during font loading.
});

/**
 * Configuration for the 'Josefin Slab' font.
 * 
 * @remarks
 * Similar to the 'Inter' font, 'Josefin Slab' is configured to target the 'latin' subset and uses the 'swap' display strategy.
 * This font provides a distinct slab-serif style and is used consistently throughout the application.
 * 
 * @returns {ReturnType<typeof Josefin_Slab>} The configured 'Josefin Slab' font.
 */
export const josefin_slab = Josefin_Slab({
  subsets: ['latin'],  // Targets the Latin character set.
  display: 'swap',     // Ensures the text is displayed with a fallback font until the web font is fully loaded.
});

/**
 * Configuration for the 'Climate Crisis' font.
 * 
 * @remarks
 * 'Climate Crisis' is also configured to use the Latin subset and the 'swap' display strategy, ensuring fast and consistent font rendering.
 * 
 * @returns {ReturnType<typeof Climate_Crisis>} The configured 'Climate Crisis' font.
 */
export const climate_crisis = Climate_Crisis({
  subsets: ['latin'],  // Includes the Latin subset for compatibility.
  display: 'swap',     // Ensures text is visible during font loading.
});

/**
 * Configuration for the 'Tilt Warp' font.
 * 
 * @remarks
 * The 'Tilt Warp' font is included with the Latin subset and uses 'swap' for its display property, maintaining consistency with other fonts in the application.
 * 
 * @returns {ReturnType<typeof Tilt_Warp>} The configured 'Tilt Warp' font.
 */
export const tiltWarp = Tilt_Warp({
  subsets: ['latin'],  // Targets the Latin character set for broad compatibility.
  display: 'swap',     // Uses 'swap' to ensure text is displayed with a fallback font while loading.
});

/**
 * Usage
 * -----
 * These configured fonts can be used throughout the application to ensure a consistent and performant typography experience.
 * By using the 'swap' display strategy, the application provides better perceived performance as text is visible quickly.
 */

---
File Path: app/layout.tsx
/**
 * File Path: app/layout.tsx
 * 
 * RootLayout Component
 * --------------------
 * This component defines the root layout for the application. It integrates global styles, toast notifications,
 * and Amplify client-side configuration. It also ensures that all child components are wrapped with 
 * foundational elements such as SEO metadata, accessibility features, and general styling.
 */

import type { Metadata } from "next"; // Import Next.js metadata type
import { ToastProvider } from "@/contexts/ToastContext"; // Import ToastProvider for toast notifications
import Toast from "@/components/Toast"; // Import Toast component for displaying notifications
import { inter } from "@/app/fonts"; // Import custom fonts (Inter) for global styling
import ConfigureAmplifyClientSide from '@/components/ConfigureAmplify'; // Import Amplify configuration for client-side setup
import "./globals.css"; // Import global CSS styles

/**
 * Metadata configuration for the entire application.
 * 
 * @remarks
 * This configuration defines the metadata for SEO purposes, such as the title and description of the site.
 */
export const metadata: Metadata = {
  title: "Meet A Drifter", 
  description: "A website that exists solely as the base of a tutorial of sorts, for now.",
};

/**
 * RootLayout Component
 * 
 * @remarks
 * The RootLayout component serves as the main wrapper for the entire application. It ensures that global styles,
 * Amplify client-side configuration, and toast notifications are applied across all pages. Additionally, it 
 * provides accessibility improvements by setting the document language and ensures that metadata for SEO is applied.
 * 
 * @param {Readonly<{ children: React.ReactNode }>} props - The properties of the RootLayout component.
 * @param {React.ReactNode} props.children - The child components that will be rendered within the layout.
 * 
 * @returns {JSX.Element} Returns the root layout component, wrapping all child components in the application.
 */
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>): JSX.Element {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ConfigureAmplifyClientSide />
        <ToastProvider>
          <Toast />
          <main>
            {children}
          </main>
        </ToastProvider>
      </body>
    </html>
  );
}

---
File Path: app/page.tsx
"use client";

/**
 * File Path: app/page.tsx
 * 
 * Home Component
 * --------------
 * This component renders the home page of the application, including animated text elements and a footer.
 * It leverages Framer Motion for animations that are triggered when the component is mounted. The animations 
 * include text sliding in, lines appearing sequentially, and the footer fading in.
 */

import { useEffect, useState, MouseEvent } from "react";
import { motion, useAnimation, AnimationControls, Variants } from "framer-motion";
import { climate_crisis, tiltWarp } from "@/app/fonts"; // Import custom fonts
import Link from "next/link";
import { Background } from "@/components/Background";

/**
 * Home Component
 * 
 * @remarks
 * This component sets up the main layout for the home page and integrates various animations
 * using Framer Motion. It ensures that the animations play sequentially on component mount.
 * The home page contains animated lines of text, a clickable footer, and a background component.
 * 
 * @returns {JSX.Element} The rendered home page with animations and interactive elements.
 */
export default function Home(): JSX.Element {
  // Animation controls for different elements of the home page.
  const centerControls: AnimationControls = useAnimation();
  const topControls: AnimationControls = useAnimation();
  const line1Controls: AnimationControls = useAnimation();
  const line2Controls: AnimationControls = useAnimation();
  const line3Controls: AnimationControls = useAnimation();
  const footerControls: AnimationControls = useAnimation();

  // State to track if the component has mounted and if animations have completed.
  const [mounted, setMounted] = useState<boolean>(false);
  const [animationsComplete, setAnimationsComplete] = useState<boolean>(false);

  // Set the component as mounted after initial render.
  useEffect(() => {
    setMounted(true);
  }, []);

  // Trigger the animation sequence once the component is mounted.
  useEffect(() => {
    if (!mounted) return;

    const sequenceAnimations = async () => {
      // Start the animations with delays between different elements.
      await new Promise((resolve) => setTimeout(resolve, 500));
      await centerControls.start("visible");

      await new Promise((resolve) => setTimeout(resolve, 2000));
      await centerControls.start("slideOut");

      setTimeout(async () => {
        await topControls.start("visible");
      }, 500);

      await new Promise((resolve) => setTimeout(resolve, 1000));
      await line1Controls.start("visible");
      await new Promise((resolve) => setTimeout(resolve, 500));
      await line2Controls.start("visible");
      await new Promise((resolve) => setTimeout(resolve, 500));
      await line3Controls.start("visible");

      await footerControls.start("visible");
      setAnimationsComplete(true);
    };

    sequenceAnimations();
  }, [mounted, centerControls, topControls, line1Controls, line2Controls, line3Controls, footerControls]);

  /**
   * Handles clicks on links and prevents navigation until animations are complete.
   * 
   * @param e - The mouse event triggered by clicking a link.
   */
  const handleClick = (e: MouseEvent<HTMLAnchorElement>): void => {
    if (!animationsComplete) e.preventDefault();
  };

  // Animation variants for the center text.
  const centerVariants: Variants = {
    hidden: { x: "-100vw", opacity: 1 },
    visible: {
      x: 0,
      opacity: 1,
      transition: { type: "spring", stiffness: 300, damping: 25 },
    },
    slideOut: { x: "100vw", opacity: 1, transition: { duration: 0.3, ease: "easeIn" } },
  };

  // Animation variants for the top text.
  const topVariants: Variants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 1, ease: "easeIn" } },
  };

  // Animation variants for the footer.
  const footerVariants: Variants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 0.5, ease: "easeIn" } },
  };

  // Animation variants for the animated lines of text.
  const lineVariants: Variants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: 0.5, ease: "easeIn" } },
  };

  // Render the home page structure.
  return (
    <>
      <Background />
      <main className="flex min-h-screen flex-col items-center justify-center overflow-hidden">
        {/* Top text with fade-in animation */}
        <motion.div
          className={`${climate_crisis.className} fixed top-6 left-4 text-white text-base sm:text-xl md:text-2xl lg:text-3xl`}
          variants={topVariants}
          initial="hidden"
          animate={topControls}
        >
          Meet A Drifter
        </motion.div>

        {/* Center text with slide-in and slide-out animations */}
        <motion.div
          className={`${climate_crisis.className} text-xl sm:text-2xl md:text-3xl lg:text-4xl text-white`}
          variants={centerVariants}
          initial="hidden"
          animate={centerControls}
        >
          Meet A Drifter
        </motion.div>

        {/* Animated lines of text with fade-in effect */}
        <div className={`${tiltWarp.className} leading-relaxed text-xl sm:text-3xl md:text-4xl md:leading-loose`}>
          <motion.div variants={lineVariants} initial="hidden" animate={line1Controls}>
            The website you join
          </motion.div>
          <motion.div variants={lineVariants} initial="hidden" animate={line2Controls}>
            so that you can build for yourself
          </motion.div>
          <motion.div variants={lineVariants} initial="hidden" animate={line3Controls}>
            the website you just joined.
          </motion.div>
        </div>

        {/* Footer with fade-in animation */}
        <motion.div
          className="fixed top-4 right-4 text-center bg-yellow-600 hover:bg-yellow-500 bg-opacity-50 hover:bg-opacity-50 border border-yellow-300 text-yellow-400 hover:text-yellow-200 p-2 px-3 rounded-lg shadow-sm shadow-yellow-700"
          variants={footerVariants}
          initial="hidden"
          animate={footerControls}
        >
          <Link href="/members" onClick={handleClick}>
            Join/Login
          </Link>
        </motion.div>

        {/* Attribution link with fade-in animation */}
        <motion.a
          href="https://www.matterandgas.com"
          className="text-white p-2 fixed bottom-2 right-3 text-xs"
          variants={footerVariants}
          initial="hidden"
          animate={footerControls}
        >
          Â© {new Date().getFullYear()} MeetADrifter
        </motion.a>
      </main>
    </>
  );
}

---
File Path: app/globals.css
/* 
 * File Path: app/globals.css
 * 
 * Purpose:
 * --------
 * This file defines global styles using Tailwind CSS, ensuring consistency across the entire application.
 * It consolidates shared styles such as buttons, containers, and form elements to avoid redundancy 
 * and improve maintainability. Additionally, it includes custom utility classes for specific design patterns.
 */

/* Import Tailwind's base, components, and utility layers */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base Layer Modifications */
@layer base {
  /* Global styles for body element: sets the background and text colors */
  body {
    @apply bg-black text-white; /* Applies a black background and white text */
  }
}

/* Custom Components */
@layer components {
  /* 
   * Button Styles 
   * -------------
   * Custom button classes for consistent button design across the application.
   */

  /* Generic button with basic styling */
  .btn {
    @apply text-xs py-2 px-3 rounded-md shadow-md; /* Small text with padding and a rounded shape */
  }

  /* Primary button style for main actions such as 'save' or 'submit' */
  .btn-primary {
    @apply bg-blue-600 text-white border border-blue-500 hover:bg-blue-700; /* Blue background with hover effects */
  }

  /* Secondary button style for less important actions such as 'cancel' */
  .btn-secondary {
    @apply bg-red-600 text-white border border-red-500 hover:bg-red-700; /* Red background with hover effects */
  }

  /* Tertiary button for alternate actions like links or minor actions */
  .btn-tertiary {
    @apply bg-yellow-600 hover:bg-yellow-500 bg-opacity-50 hover:bg-opacity-50 border border-yellow-300 text-yellow-400 hover:text-yellow-200; /* Yellow background with opacity and hover transitions */
  }

  /*
   * Container Styles
   * ----------------
   * Generic container styles used for section content or grouping elements.
   */

  /* Generic container for section content with blurred background */
  .section-container {
    @apply w-full my-1 p-2 backdrop-blur-md bg-white bg-opacity-35 rounded-lg; /* Full width, padding, and a blurred white background */
  }

  /*
   * Text Styling
   * ------------
   * Common heading styles for section titles or page headings.
   */

  /* Shared heading styles for titles or section headers */
  .heading {
    @apply font-extralight text-2xl text-left p-3; /* Large, light font with padding */
  }

  /*
   * Form Elements
   * -------------
   * Standard styles for form input fields used throughout the application.
   */

  /* Input field styling for form elements */
  .form-input {
    @apply p-2 mb-3 w-full text-xs sm:text-sm md:text-base text-white rounded border bg-blue-950 bg-opacity-20; /* Full-width input with padding and a semi-transparent background */
  }

  /*
   * Background Image Styling
   * ------------------------
   * Styles for full-screen fixed background images with effects.
   */

  /* Full-screen, fixed background image with a blur effect */
  .bg-image {
    @apply w-full h-screen fixed top-0 left-0 -z-50; /* Covers the entire screen and is fixed behind content */
    object-fit: cover; /* Ensures the image scales properly to cover the entire background */
  }

  /*
   * Centered Heading
   * ----------------
   * Styles for centered headings, typically used for page titles or main headings.
   */

  /* Fixed, centered heading typically used for page titles */
  .centered-heading {
    @apply fixed top-3 left-2 text-xl sm:text-2xl md:text-3xl lg:text-4xl lg:left-4 text-white; /* White text with size adjustments based on screen size */
  }

  /*
   * Custom Member Button
   * --------------------
   * A custom-styled button for member-related actions such as login or signup.
   */

  /* Button specifically for member-related actions */
  .member-btn {
    @apply btn w-24 mx-2 mt-4 bg-teal-600 hover:bg-teal-500; /* Width and margin adjustments with teal background */
  }
}

/* Global Utility Classes */
@layer utilities {
  /* Define any additional utility classes as needed for global use */
}

---
File Path: app/members/layout.tsx
/**
 * File Path: app/members/layout.tsx
 * 
 * Member Layout Component
 * -----------------------
 * This component defines the layout specifically for member areas of the application. It incorporates
 * AWS Amplify authentication, dynamic background opacity control, and conditionally renders
 * member or admin menus based on the application's pathname. Additionally, it provides a configurable
 * background and navigation bar with animations.
 */

"use client";

import { useState } from "react";
import { Authenticator, View } from "@aws-amplify/ui-react";
import { Amplify } from "aws-amplify";
import { motion } from "framer-motion";
import outputs from "@/amplify_outputs.json";
import Image from "next/image";
import bg from "@/public/nacho-champion.png";
import "@aws-amplify/ui-react/styles.css";
import { AuthProvider, useAuth } from "@/contexts/AuthContext";
import AuthenticatedNavBar from "@/components/AuthenticatedNavBar"; // Import for authenticated navigation bar
import MembersMenu from "@/components/MembersMenu";
import { Bars3Icon } from "@heroicons/react/24/solid";
import { climate_crisis } from "@/app/fonts";

// Configure AWS Amplify using the generated outputs
Amplify.configure(outputs);

// Custom sign-up form fields for Amplify's Authenticator
const formFields = {
  signUp: {
    email: {
      order: 1,
      label: "Email",
      placeholder: "Enter your email address",
    },
    password: {
      order: 2,
      label: "Password",
      placeholder: "Enter your password",
    },
    confirm_password: {
      order: 3,
      label: "Confirm Password",
      placeholder: "Confirm your password",
    },
    preferred_username: {
      order: 4,
      label: "Username",
      placeholder: "Enter your unique username",
    },
    given_name: {
      order: 5,
      label: "First Name",
      placeholder: "Enter your first name",
    },
    family_name: {
      order: 6,
      label: "Last Name",
      placeholder: "Enter your last name",
    },
  },
};

// Custom header component for Amplify's Authenticator
const components = {
  Header() {
    return (
      <View
        as="div"
        fontFamily={climate_crisis.style.fontFamily}
        textAlign="center"
        margin="16px 0"
        fontSize="2rem"
        color="var(--amplify-colors-white)"
      >
        Meet A Drifter
      </View>
    );
  },
};

/**
 * Layout Component
 * 
 * @remarks
 * The root layout component for member-specific sections of the application. It handles background
 * image opacity adjustments, menu toggle controls, and manages authenticated navigation for users.
 * AWS Amplify is used to manage authentication flows.
 * 
 * @param {Readonly<{ children: React.ReactNode }>} props - The children components to be rendered within the layout.
 * 
 * @returns {JSX.Element} The layout component that wraps all member-specific pages.
 */
export default function Layout({
  children,
}: Readonly<{ children: React.ReactNode }>): JSX.Element {
  const [bgOpacity, setBgOpacity] = useState<number>(0.65); // Background opacity state
  const [menuOpen, setMenuOpen] = useState<boolean>(false); // Menu open/close state

  /**
   * Updates the background opacity state based on user input.
   * 
   * @param {React.ChangeEvent<HTMLInputElement>} event - The input change event from the background opacity slider.
   */
  const handleOpacityChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setBgOpacity(parseFloat(event.target.value));
  };

  /**
   * Toggles the state of the navigation menu between open and closed.
   */
  const toggleMenu = () => {
    setMenuOpen((prev) => !prev);
  };

  return (
    <Authenticator
      formFields={formFields}
      components={components}
      variation="modal"
      hideSignUp={false}
    >
      {({ signOut, user }) => (
        <AuthProvider user={user || null} signOut={signOut || (() => {})}>
          <LayoutContent
            bgOpacity={bgOpacity}
            handleOpacityChange={handleOpacityChange}
            menuOpen={menuOpen}
            toggleMenu={toggleMenu}
          >
            {children}
          </LayoutContent>
        </AuthProvider>
      )}
    </Authenticator>
  );
}

/**
 * LayoutContent Component
 * 
 * @remarks
 * This component renders the core layout content including the background image, animated menu,
 * and child components. It provides controls for background opacity and the member's navigation menu.
 * 
 * @param {number} bgOpacity - The opacity level of the background image.
 * @param {(event: React.ChangeEvent<HTMLInputElement>) => void} handleOpacityChange - Function to handle background opacity adjustments.
 * @param {boolean} menuOpen - The state indicating whether the menu is open or closed.
 * @param {() => void} toggleMenu - Function to toggle the menu open/close state.
 * @param {React.ReactNode} children - The content to be rendered within the layout.
 * 
 * @returns {JSX.Element} The rendered layout content component.
 */
function LayoutContent({
  bgOpacity,
  handleOpacityChange,
  menuOpen,
  toggleMenu,
  children,
}: {
  bgOpacity: number;
  handleOpacityChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  menuOpen: boolean;
  toggleMenu: () => void;
  children: React.ReactNode;
}): JSX.Element {
  const { loading } = useAuth(); // Authentication context to determine if user status is loading

  if (loading) {
    return <div>Loading...</div>; // Display a loading message while authentication is being checked
  }

  return (
    <div className="w-full text-center">
      <div
        className="w-full h-screen fixed top-0 left-0 -z-50"
        style={{ opacity: bgOpacity }}
      >
        <Image
          src={bg}
          alt="Nacho Champion - The greatest moment of one man's life."
          fill
          style={{ objectFit: "cover" }}
        />
      </div>
      <div className="fixed top-0 left-0 right-0 z-20">
        <div className={`${climate_crisis.className} fixed top-6 left-4 text-white lg:text-xl`}>
          Meet A Drifter
        </div>
        <div className="mt-16 md:mt-5 md:-mr-32">
          {/* Render the navigation bar */}
          <AuthenticatedNavBar />
        </div>
        <div className="z-20">
          {/* Menu Button */}
          {!menuOpen && (
            <button className="fixed top-0 right-6 text-white pt-6" onClick={toggleMenu}>
              <Bars3Icon className="size-7 text-white" />
            </button>
          )}
        </div>
      </div>
      <div className="z-40">
        {/* Members Menu */}
        <motion.div
          initial={{ y: "-100%" }}
          animate={{ y: menuOpen ? 0 : "-100%" }}
          exit={{ y: "-100%" }}
          transition={{ type: "spring", stiffness: 50 }}
          className="fixed top-0 w-full z-40"
          style={{ height: "100vh" }}
        >
          <MembersMenu
            bgOpacity={bgOpacity}
            handleOpacityChange={handleOpacityChange}
            toggleMenu={toggleMenu}
            isMenuOpen={menuOpen}
          />
        </motion.div>
      </div>

      <div className="fixed top-0 h-32 md:h-20 w-full backdrop-blur-lg z-10"></div>
      <div className="mt-24">{children}</div>
    </div>
  );
}

---
File Path: app/members/page.tsx
/**
 * File Path: app/members/page.tsx
 * 
 * Member Home Component
 * ---------------------
 * This component defines the Home page for member-specific areas of the application. It displays 
 * personalized user information, handles site notifications, and integrates authentication context 
 * to provide user-specific actions such as signing out. Additionally, the Poll component is rendered 
 * to allow users to interact with active polls.
 */

"use client";

import { useEffect, useState } from "react";
import { generateClient } from "aws-amplify/data"; // Import Amplify Data Client
import type { Schema } from "@/amplify/data/resource"; // Import the data schema type
import { useAuth } from "@/contexts/AuthContext"; // Import useAuth hook to access authentication context
import Poll from "@/components/Poll"; // Import Poll component for rendering active polls

/**
 * Interface representing a Site Notification.
 */
interface SiteNotification {
  message: string; // The message content of the notification
}

// Generate an Amplify client instance with the defined schema
const client = generateClient<Schema>();

/**
 * Home Component
 * --------------
 * The Home component serves as the member's landing page, displaying profile information, site notifications,
 * and other personalized content based on authentication context.
 * 
 * @returns {JSX.Element} The rendered Home component for member areas.
 */
export default function Home(): JSX.Element {
  // Access user details, profile, and loading state from authentication context
  const { user, profile, loading, isAdmin } = useAuth();
  const [notification, setNotification] = useState<string | null>(null); // State to manage site notification

  // Fetch the current site notification when the component mounts
  useEffect(() => {
    const fetchNotification = async () => {
      try {
        const { data, errors } = await client.models.SiteNotification.list({});
        if (errors) {
          console.error("Failed to fetch notification", errors);
          return;
        }
        // Assume there's only one active notification
        const currentNotification = data[0] as SiteNotification | undefined;
        setNotification(currentNotification?.message || null);
      } catch (err) {
        console.error("Error fetching notification:", err);
      }
    };

    fetchNotification();
  }, []);

  return (
    <main className="flex min-h-screen flex-col items-center py-8 mx-2 sm:mx-1 md:mx-2">
      <div className="w-full max-w-5xl">
        {/* Display the site notification if available */}
        {notification && (
          <div className="section-container pb-4 sm:p-4">
            <div className="heading">Notifications</div>
            <div className="bg-black bg-opacity-70 p-4 rounded-lg flex flex-col sm:flex-row sm:justify-between items-start sm:items-center space-y-4 sm:space-y-0">
              {notification}
            </div>
          </div>
        )}
      </div>
      <div className="w-full max-w-5xl">
        <div className="flex flex-col sm:flex-row md:space-x-8">
          {/* Render Profile Section */}
          <div className="section-container sm:mr-1 md:mr-0 pb-4 sm:p-4 h-min">
            <h2 className="heading">Profile</h2>
            {loading ? (
              <p className="text-center text-gray-700">Loading profile...</p>
            ) : profile ? (
              <div className="bg-black bg-opacity-70 p-4 rounded-lg">
                <div className="">
                  <p className="mb-2">
                    <strong>Username:</strong> {profile.username}
                  </p>
                  <p className="mb-2">
                    <strong>Name:</strong> {profile.firstName} {profile.lastName}
                  </p>
                  <p className="mb-2">
                    <strong>Email:</strong> {profile.emailAddress}
                  </p>
                  <p className="mb-2">
                    <strong>ID:</strong> {user?.username}
                  </p>
                  {isAdmin && (
                    <p className="mt-2 text-red-700 font-bold">Administrator</p>
                  )}
                </div>
              </div>
            ) : (
              <p className="text-center text-gray-700">
                No profile information available.
              </p>
            )}
          </div>
          {/* Render Poll Component */}
          <Poll />
        </div>
      </div>
    </main>
  );
}

---
File Path: app/members/admin/layout.tsx
/**
 * File Path: @/app/members/admin/layout.tsx
 * 
 * Admin Layout Component
 * ----------------------
 * This component defines the layout for all admin-specific pages within the application. It ensures that
 * only users with admin privileges can access these pages. If a non-admin user attempts to access the 
 * admin area, they are automatically redirected to the members' homepage. Additionally, the component
 * integrates with the `ToastContext` to display notifications and manages loading states during admin 
 * status verification.
 */

"use client";

import { useEffect } from "react";
import { useAuth } from "@/contexts/AuthContext"; // Hook for accessing authentication context.
import { useRouter } from "next/navigation"; // Import the Next.js useRouter for navigation handling.
import type { ReactNode } from "react";

/**
 * AdminLayout Component
 * 
 * @remarks
 * This component serves as the layout wrapper for all admin pages. It checks the user's admin status and 
 * redirects non-admin users to the members' homepage. While checking admin status, it can display a loading
 * state to avoid rendering content prematurely.
 * 
 * @param {Readonly<{ children: ReactNode }>} props - The component's props, specifically the child elements to render within the layout.
 * 
 * @returns {JSX.Element} The rendered AdminLayout component for admin-specific pages.
 */
export default function AdminLayout({
  children,
}: Readonly<{ children: ReactNode }>): JSX.Element {
  const { isAdmin, loading } = useAuth(); // Destructure isAdmin and loading state from authentication context.
  const router = useRouter(); // Router for redirecting users.

  useEffect(() => {
    /**
     * Admin Status Check
     * 
     * Monitors the admin status and redirects the user to the members' homepage if they are not an admin.
     * It waits for the loading state to complete before making this decision.
     */
    if (!loading) {
      if (!isAdmin) {
        console.log("User is not an admin, redirecting...");
        router.push("/members");
      }
    }
  }, [loading, isAdmin, router]);

  if (loading) {
    return <div>Loading...</div>; // Display a loading state while checking admin status.
  }

  return (
    <main className="flex flex-col w-full min-h-screen py-12 items-center">
      {/* Main content area */}
      <div className="flex-grow w-full px-4">
        {children}
      </div>
    </main>
  );
}

---
File Path: app/members/admin/page.tsx
/**
 * File Path: @/app/members/admin/page.tsx
 * 
 * Admin Page Component
 * --------------------
 * This component defines the admin page for managing polls. It provides sections for listing existing
 * polls and creating new ones. The layout is responsive, ensuring the user interface adapts to various
 * screen sizes, particularly for larger viewports.
 */

import CurrentPoll from "@/components/CurrentPoll";

/**
 * AdminPage Component
 * 
 * @remarks
 * This component renders the main admin dashboard, focused on poll management. It displays existing polls
 * via the `CurrentPoll` component and ensures that the layout is responsive for an optimal user experience
 * across different screen sizes.
 * 
 * @returns {JSX.Element} The rendered AdminPage component with sections for managing polls.
 */
export default function AdminPage(): JSX.Element {
  return (
    <main className="w-full justify-center">
      <div className="">
        <div className="md:flex md:justify-around">
          {/* Section for listing existing polls */}
          <div className="md:w-full">
            <CurrentPoll />
          </div>
        </div>
      </div>
    </main>
  );
}

---
File Path: app/members/admin/code/page.tsx
"use client";

/**
 * File Path: @/app/members/admin/code/page.tsx
 * 
 * AdminCodePage Component
 * -----------------------
 * This component provides an interface for administrators to manage lessons. Administrators can create new lessons,
 * update existing ones, and reorder lesson items. The page integrates several components to handle these operations,
 * including lesson listing, CRUD operations, and lesson ordering.
 */

import React, { useState } from "react";
import AllLessonsList from "@/components/AllLessonsList"; // Component for listing all lessons
import LessonForm from "@/components/LessonForm"; // Component for creating or updating lessons
import LessonOrder from "@/components/LessonOrder"; // Component for managing lesson order

/**
 * DisplayState Type
 * -----------------
 * Defines the possible states for displaying content on the page: either the lesson list or the lesson form.
 */
type DisplayState = "list" | "form";

/**
 * AdminCodePage Component
 * 
 * @remarks
 * This component is designed for administrators to manage lessons within the application. It provides
 * functionalities to display a list of all lessons, handle CRUD operations through a lesson form, and
 * manage the order of lessons via a dedicated section. The display state alternates between the list view
 * and the form view based on user interaction.
 * 
 * @returns {JSX.Element} The rendered AdminCodePage component for managing lessons and lesson order.
 */
export default function AdminCodePage(): JSX.Element {
  // State to track the currently selected lesson ID for update or null for creating a new lesson.
  const [selectedLessonId, setSelectedLessonId] = useState<string | null>(null);

  // State to determine whether to display the list of lessons or the lesson form for CRUD operations.
  const [displayState, setDisplayState] = useState<DisplayState>("list");

  /**
   * Displays the lesson form for creating a new lesson or editing an existing lesson.
   * 
   * @param {string | null} lessonId - The ID of the lesson to edit, or "new" for creating a new lesson.
   */
  const showLessonForm = (lessonId: string | null): void => {
    setSelectedLessonId(lessonId);
    setDisplayState("form");
  };

  /**
   * Displays the list of all lessons.
   */
  const showLessonList = (): void => {
    setDisplayState("list");
  };

  // Render the main layout with sections for managing lessons and lesson order.
  return (
    <main className="section-container w-full lg:flex">
      {/* Section for managing the list of lessons or displaying the lesson form */}
      <div className="text-left flex flex-col md:flex-row md:space-x-6 md:mr-1 w-full">
        {displayState === "list" ? (
          <div className="w-full">
            <AllLessonsList onSelectItem={showLessonForm} /> {/* Render the list of all lessons */}
            <button
              className="btn btn-primary mt-4 lg:mt-2"
              onClick={() => showLessonForm("new")}
            >
              Add New Lesson
            </button>
          </div>
        ) : (
          <div className="w-full">
            <LessonForm
              selectedLessonId={selectedLessonId} // Pass the selected lesson ID for updating or null for creating a new lesson.
              resetSelection={showLessonList} // Reset to the lesson list view after form submission or cancellation.
            />
          </div>
        )}
      </div>

      {/* Section for managing the order of lessons */}
      <div className="flex flex-col md:flex-row md:space-x-6 w-full md:mr-1 mt-8 lg:mt-0">
        <LessonOrder /> {/* Render the LessonOrder component for reordering lessons */}
      </div>
    </main>
  );
}

---
File Path: app/members/admin/polls/page.tsx
/**
 * File Path: @/app/members/admin/polls/page.tsx
 * 
 * Polls Page Component
 * --------------------
 * This component defines the admin page for managing polls. It provides sections for displaying the list
 * of existing polls and creating new polls. The layout is responsive and ensures that components are displayed
 * in a flexible layout that adapts to various screen sizes.
 */

import CreatePoll from "@/components/CreatePoll"; // Component for creating new polls.
import ListPolls from "@/components/ListPolls"; // Component for listing existing polls.

/**
 * AdminPollPage Component
 * 
 * @remarks
 * This component renders the admin dashboard for managing polls. It includes two main sections: one for listing
 * all existing polls and another for creating new polls. The layout is responsive, flexing between columns or
 * rows depending on screen size. The components take full width on smaller screens and share space on larger screens.
 * 
 * @returns {JSX.Element} The rendered AdminPollPage component for managing polls.
 */
export default function AdminPollPage(): JSX.Element {
  return (
    <main className="w-full">
      <div className="">
        <div className="flex flex-col md:flex-row justify-center md:space-x-6 w-full">
          {/* Section for listing existing polls */}
          <div className="w-full md:w-1/2">
            <ListPolls /> {/* Render the ListPolls component */}
          </div>
          {/* Section for creating new polls */}
          <div className="w-full md:w-1/2">
            <CreatePoll /> {/* Render the CreatePoll component */}
          </div>
        </div>
      </div>
    </main>
  );
}

---
File Path: app/members/admin/users/page.tsx
"use client";

/**
 * File Path: @/app/members/admin/users/page.tsx
 *
 * Users Page Component
 * --------------------
 * This component provides an interface for administrators to view and manage users,
 * including their group memberships. Administrators can add or remove users from groups,
 * and the layout adapts for both mobile and desktop screens.
 */

import React, { useEffect, useState } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

// Define TypeScript interfaces for the expected data structures

/**
 * Interface for individual user attributes such as email and verification status.
 */
interface UserAttribute {
  Name: string;
  Value: string;
}

/**
 * Interface for Cognito user data with associated attributes.
 */
interface CognitoUser {
  Username: string;
  Attributes: UserAttribute[];
}

/**
 * Interface for Cognito groups that a user is associated with.
 */
interface CognitoGroup {
  GroupName: string;
}

/**
 * Interface for a user with their associated groups.
 */
interface UserWithGroups {
  user: CognitoUser;
  groups: CognitoGroup[];
}

// Generate the Amplify client with the schema
const client = generateClient<Schema>();

/**
 * AdminUserPage Component
 * -----------------------
 * Renders a page for administrators to view and manage users and their group memberships.
 * Administrators can add or remove users from groups, and the component handles fetching and
 * updating user data from the backend.
 * 
 * @returns {JSX.Element} The rendered AdminUserPage component for user management.
 */
export default function AdminUserPage(): JSX.Element {
  const [users, setUsers] = useState<UserWithGroups[]>([]); // State for storing the list of users with their groups
  const [error, setError] = useState<string | null>(null); // State for handling errors

  /**
   * Fetches the list of users and their groups from the backend and updates the state.
   */
  const fetchUsers = async (): Promise<void> => {
    try {
      const response = await client.queries.listUsersAndGroups({});
      let responseData = response.data;

      // Handle potential stringified response
      if (typeof responseData === "string") {
        responseData = JSON.parse(responseData);
      }

      if (Array.isArray(responseData)) {
        setUsers(responseData as UserWithGroups[]);
      } else {
        console.error("Invalid response structure:", responseData);
        setError("Failed to load users.");
      }
    } catch (err) {
      console.error("Error fetching users:", err);
      setError("Failed to load users.");
    }
  };

  // Fetch users on component mount
  useEffect(() => {
    fetchUsers();
  }, []);

  /**
   * Adds a user to the specified group and refreshes the user list.
   * 
   * @param {string} username - The username of the user.
   * @param {string} groupName - The name of the group to add the user to.
   */
  const handleAddUserToGroup = async (username: string, groupName: string): Promise<void> => {
    try {
      await client.mutations.addUserToGroup({ username, groupName });
      await fetchUsers(); // Refresh the user list after adding
    } catch (err) {
      console.error("Error adding user to group:", err);
    }
  };

  /**
   * Removes a user from the specified group and refreshes the user list.
   * 
   * @param {string} username - The username of the user.
   * @param {string} groupName - The name of the group to remove the user from.
   */
  const handleRemoveUserFromGroup = async (username: string, groupName: string): Promise<void> => {
    try {
      await client.mutations.removeUserFromGroup({ username, groupName });
      await fetchUsers(); // Refresh the user list after removing
    } catch (err) {
      console.error("Error removing user from group:", err);
    }
  };

  /**
   * Checks if a given user belongs to the "admin" group.
   * 
   * @param {CognitoGroup[]} groups - The groups the user belongs to.
   * @returns {boolean} True if the user is in the "admin" group.
   */
  const isUserAdmin = (groups: CognitoGroup[]): boolean => {
    return groups.some((group) => group.GroupName === "admin");
  };

  return (
    <main className="w-full section-container">
      <div className="text-xs shadow-lg rounded-lg overflow-hidden">
        <div className="px-5 text-white pt-5 heading">
          Users
        </div>
        {error && <p className="text-red-500">{error}</p>}
        <div className="p-4 flex flex-col space-y-4">
          {users.length === 0 && !error ? (
            <p className="text-center text-white">No users found.</p>
          ) : (
            users.map((userWithGroups) => {
              const isAdmin = isUserAdmin(userWithGroups.groups);

              return (
                <div
                  key={userWithGroups.user.Username}
                  className="bg-black bg-opacity-70 p-4 rounded-lg flex flex-col sm:flex-row sm:justify-between items-start sm:items-center space-y-4 sm:space-y-0"
                >
                  {/* Left aligned user info */}
                  <div className="flex flex-col text-left text-xs sm:text-sm space-y-2 w-full sm:w-auto">
                    <div>
                      <span className="font-bold">Username: </span>
                      {userWithGroups.user.Username}
                    </div>
                    <div>
                      <span className="font-bold">Email: </span>
                      {userWithGroups.user.Attributes.find(
                        (attr) => attr.Name === "email"
                      )?.Value || "N/A"}
                    </div>
                    <div>
                      <span className="font-bold">Groups: </span>
                      {userWithGroups.groups.length > 0
                        ? userWithGroups.groups.map((group) => group.GroupName).join(", ")
                        : "No groups assigned"}
                    </div>
                  </div>

                  {/* Conditionally render action buttons based on admin status */}
                  <div className="flex flex-row justify-center w-full sm:w-auto space-x-4">
                    {!isAdmin && (
                      <button
                        onClick={() =>
                          handleAddUserToGroup(userWithGroups.user.Username, "admin")
                        }
                        className="btn btn-primary"
                      >
                        Add to Admin Group
                      </button>
                    )}
                    {isAdmin && (
                      <button
                        onClick={() =>
                          handleRemoveUserFromGroup(userWithGroups.user.Username, "admin")
                        }
                        className="btn btn-secondary"
                      >
                        Remove from Admin Group
                      </button>
                    )}
                  </div>
                </div>
              );
            })
          )}
        </div>
      </div>
    </main>
  );
}

---
File Path: app/members/admin/messaging/page.tsx
"use client";

/**
 * File Path: @/app/members/admin/messaging/page.tsx
 * 
 * Messaging Page Component
 * ------------------------
 * This component allows administrators to create, update, or delete a site-wide notification message.
 * The page includes a textarea for managing the message content and integrates with toast notifications 
 * to provide feedback to the user. The layout is responsive and adapts to various screen sizes.
 */

import React, { useState, useEffect } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { useContext } from "react";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext"; // Toast notifications context

/**
 * Interface representing the site notification object.
 */
interface SiteNotification {
  id: string;
  message: string;
}

// Generate an Amplify client instance with the defined schema
const client = generateClient<Schema>();

/**
 * AdminMessagingPage Component
 * 
 * @remarks
 * This component allows administrators to manage a site-wide notification. The notification can be created,
 * updated, or deleted, and the component provides feedback via toast notifications. Error handling is included
 * for all operations, and the current notification is fetched when the component is first rendered.
 * 
 * @returns {JSX.Element} The rendered AdminMessagingPage component for managing the site notification.
 */
export default function AdminMessagingPage(): JSX.Element {
  const [notification, setNotification] = useState<SiteNotification | null>(null); // State to store current notification
  const [message, setMessage] = useState<string>(""); // State to store the textarea message content
  const [error, setError] = useState<string | null>(null); // State for handling errors
  const { addToast } = useContext<ToastContextType>(ToastContext); // Access toast notifications from ToastContext

  // Fetch the current site notification when the component is mounted
  useEffect(() => {
    const fetchNotification = async () => {
      try {
        const { data, errors } = await client.models.SiteNotification.list({});
        if (errors) {
          setError("Failed to fetch notification");
          addToast({
            messageType: "error",
            message: "Failed to fetch site notification.",
          });
          return;
        }
        // Assume there is only one notification for simplicity
        const currentNotification = data[0] as SiteNotification | undefined;
        setNotification(currentNotification || null);
        setMessage(currentNotification?.message || "");
      } catch (err) {
        console.error("Error fetching notification:", err);
        setError("Failed to fetch notification");
        addToast({
          messageType: "error",
          message: "An error occurred while fetching the notification.",
        });
      }
    };

    fetchNotification();
  }, [addToast]);

  /**
   * Handles saving or updating the notification.
   * If a notification exists, it updates it; otherwise, it creates a new one.
   */
  const handleSave = async (): Promise<void> => {
    try {
      if (notification) {
        // Update the existing notification
        const { errors } = await client.models.SiteNotification.update({
          id: notification.id,
          message,
        });
        if (errors) throw new Error("Failed to update notification");
      } else {
        // Create a new notification
        const { errors } = await client.models.SiteNotification.create({
          message,
        });
        if (errors) throw new Error("Failed to create notification");
      }
      addToast({
        messageType: "success",
        message: "Notification saved successfully!",
      });
    } catch (err) {
      console.error("Error saving notification:", err);
      setError("Failed to save notification");
      addToast({
        messageType: "error",
        message: "An error occurred while saving the notification.",
      });
    }
  };

  /**
   * Handles deleting the notification if one exists.
   */
  const handleDelete = async (): Promise<void> => {
    try {
      if (!notification) return;
      const { errors } = await client.models.SiteNotification.delete({ id: notification.id });
      if (errors) throw new Error("Failed to delete notification");
      setNotification(null);
      setMessage("");
      addToast({
        messageType: "success",
        message: "Notification deleted successfully!",
      });
    } catch (err) {
      console.error("Error deleting notification:", err);
      setError("Failed to delete notification");
      addToast({
        messageType: "error",
        message: "An error occurred while deleting the notification.",
      });
    }
  };

  return (
    <main className="w-full lg:w-3/4 xl:w-2/3 m-auto flex justify-center">
      <div className="w-full p-2 backdrop-blur-md bg-white bg-opacity-35 rounded-lg">
        <h2 className="p-3 font-extralight text-2xl text-left">Manage Site Notification</h2>
        <div className="bg-black bg-opacity-70 p-4 rounded-lg w-full">
          {error && <p className="text-red-500 mb-4">{error}</p>}
          <div className="mb-4 w-full">
            <label className="block text-white text-xs text-left">Notification Message</label>
            <textarea
              className="form-input"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Enter the site-wide notification message..."
              rows={10}
            />
          </div>
          <div className="flex justify-between mt-4">
            <button
              onClick={handleSave}
              className="p-2 text-xs bg-blue-600 text-white rounded-lg hover:bg-blue-700 border border-blue-500"
            >
              Save Notification
            </button>
            {notification && (
              <button
                onClick={handleDelete}
                className="p-2 text-xs bg-red-600 text-white rounded-lg hover:bg-red-700 border border-red-500"
              >
                Delete Notification
              </button>
            )}
          </div>
        </div>
      </div>
    </main>
  );
}

---
File Path: app/members/code/generateStaticParams.ts
/**
 * File Path: @/app/members/code/[slug]/generateStaticParams.ts
 * 
 * Static Params Generation
 * ------------------------
 * This module defines the `generateStaticParams` function, which is responsible for generating
 * the dynamic route parameters based on lesson slugs. It fetches data from the `LessonContent`
 * model in AWS Amplify to dynamically build the slugs for each lesson.
 */

import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

// Generate the Amplify client using the defined schema
const client = generateClient<Schema>();

/**
 * generateStaticParams
 * --------------------
 * Asynchronously generates the parameters for dynamic routes based on lesson slugs. This is used to
 * statically generate dynamic pages in a Next.js application, allowing for the pre-rendering of
 * pages corresponding to each lesson.
 * 
 * @async
 * @function
 * @returns {Promise<Array<{ slug: string }>>} A promise that resolves to an array of objects,
 * each containing a `slug` property corresponding to the lesson slug.
 */
export async function generateStaticParams(): Promise<Array<{ slug: string }>> {
  // Fetch all lesson entries from the LessonContent model
  const { data: lessons } = await client.models.LessonContent.list();

  // Map through the lessons and return an array of objects with the slug for each lesson
  return (lessons || []).map((item) => ({ slug: item.slug }));
}

---
File Path: app/members/code/page.tsx
"use client";

/**
 * File Path: @/app/members/code/page.tsx
 * 
 * Member Code Page Component
 * --------------------------
 * This component manages the redirection of users based on their lesson progress stored in `localStorage`.
 * It checks if the `lessonStage` exists in `localStorage` and redirects users accordingly.
 * If no progress is found, the component initializes the `lessonStage` and redirects the user to the welcome page.
 */

import React, { useEffect } from "react";
import { useRouter } from "next/navigation"; // Import useRouter for client-side navigation

/**
 * MemberCodePage Component
 * 
 * @remarks
 * This component checks the user's lesson progress by accessing the `lessonStage` from the browser's
 * localStorage. Based on the `lessonStage`, the user is redirected to the appropriate lesson page.
 * If no lesson progress is found, the component initializes the progress and redirects the user to the
 * welcome lesson page.
 * 
 * @returns {JSX.Element} A rendered component that shows a loading message while the redirection is being handled.
 */
export default function MemberCodePage(): JSX.Element {
  const router = useRouter();

  /**
   * useEffect Hook
   * --------------
   * On component mount, this effect checks the presence of `lessonStage` in localStorage. If it's not found,
   * the hook initializes the stage to "welcome" and redirects the user to the welcome lesson page.
   * If a lesson stage is found, the user is redirected to the appropriate lesson page based on the stored value.
   */
  useEffect(() => {
    const lessonStage = localStorage.getItem("lessonStage");

    if (!lessonStage) {
      // Initialize `lessonStage` to "welcome" if it doesn't exist and redirect to the welcome page
      localStorage.setItem("lessonStage", "welcome");
      router.push("/members/code/welcome");
    } else {
      // Redirect to the lesson corresponding to the current `lessonStage`
      router.push(`/members/code/${lessonStage}`);
    }
  }, [router]);

  return (
    <main className="w-full flex justify-center">
      <div className="w-full p-6 mt-16 max-w-3xl mx-auto">
        <span>Checking lesson progress...</span>
      </div>
    </main>
  );
}

---
File Path: app/members/code/[slug]/layout.tsx
/**
 * File Path: app/members/code/[slug]/layout.tsx
 * 
 * Layout Component
 * ----------------
 * This component fetches the ordered list of lessons, determines the current lesson's
 * position, and renders the Table of Contents and Lesson Navigation alongside the page content.
 */

import React from "react";
import Link from "next/link";
import { cookiesClient } from "@/utils/amplifyServerUtils";
import {
  ArrowLeftCircleIcon,
  ArrowRightCircleIcon,
} from "@heroicons/react/24/solid";
import TableOfContents from "@/components/TableOfContents";
import SetLessonStage from "@/components/SetLessonStage";
import { LessonContent } from "@/types/LessonContent";

/**
 * LayoutProps Interface
 * ---------------------
 * Defines the properties for the Layout component, including the route parameters and children.
 */
interface LayoutProps {
  children: React.ReactNode;
  params: {
    slug: string;
  };
}

/**
 * Layout Component
 * ----------------
 * This component serves as the layout for the lesson pages. It fetches the ordered list of lessons,
 * determines the current lesson's position, and renders the Table of Contents and navigation links.
 * 
 * @param {LayoutProps} props - The component props containing the children elements and route parameters.
 * @returns {JSX.Element} The rendered layout with lesson navigation, table of contents, and lesson content.
 */
const Layout: React.FC<LayoutProps> = async ({ children, params }) => {
  const { slug } = params;

  try {
    const { data: lessonOrderData, errors: orderErrors } =
      await cookiesClient.models.LessonContent.list({
        filter: { isOrdered: { eq: true } },
      });

    if (orderErrors || !lessonOrderData) {
      console.error("Error fetching lesson order data:", orderErrors);
      return <div className="text-red-500">Error loading lessons.</div>;
    }

    // Map and sort lessons by orderIndex
    const sortedLessonOrder: LessonContent[] = lessonOrderData
      .map(({ id, title, slug, code, docs, isOrdered, orderIndex, links }) => ({
        id,
        title,
        slug,
        code,
        docs,
        isOrdered,
        orderIndex,
        links: (links || []).filter(
          (link): link is { text: string; url: string } =>
            link?.text !== null && link?.url !== null
        ),
      }))
      .sort((a, b) => (a.orderIndex ?? 0) - (b.orderIndex ?? 0));

    // Find the current lesson based on the slug
    const currentLessonIndex = sortedLessonOrder.findIndex(
      (lesson) => lesson.slug === slug
    );

    if (currentLessonIndex === -1) {
      console.error(`Lesson with slug "${slug}" not found.`);
      return <div className="text-red-500">Lesson not found.</div>;
    }

    const currentLesson = sortedLessonOrder[currentLessonIndex];
    const nextLesson = sortedLessonOrder[currentLessonIndex + 1] || null;
    const prevLesson = sortedLessonOrder[currentLessonIndex - 1] || null;

    // Utility to generate navigation links
    const renderNavLink = (
      lesson: LessonContent | null,
      direction: "prev" | "next"
    ) => {
      if (!lesson) return null;
      const isPrev = direction === "prev";
      const Icon = isPrev ? ArrowLeftCircleIcon : ArrowRightCircleIcon;
      const label = isPrev
        ? `Go to previous lesson: ${lesson.title}`
        : `Go to next lesson: ${lesson.title}`;
      return (
        <Link
          href={`/members/code/${lesson.slug}`}
          className="text-white hover:text-green-400 transition-colors duration-200"
          aria-label={label}
        >
          <Icon className="size-10" />
        </Link>
      );
    };

    return (
      <>
        <SetLessonStage slug={slug} />
        <div className="relative w-full min-h-screen bg-gray-900 text-white">
          <div className="fixed top-32 sm:top-28 md:top-20 left-0 right-0 bg-sky-950 bg-opacity-100 px-4 py-1 z-20">
            <div className="max-w-xl mx-auto grid grid-cols-3 items-center gap-2 rounded-lg">
              {/* Previous Lesson */}
              <div className="justify-self-start">
                {renderNavLink(prevLesson, "prev")}
              </div>

              {/* Current Lesson Title */}
              <h1 className="font-bold text-center text-sm">
                {currentLesson.title}
              </h1>

              {/* Next Lesson */}
              <div className="justify-self-end">
                {renderNavLink(nextLesson, "next")}
              </div>
            </div>
          </div>

          {/* Table of Contents */}
          <aside className="fixed top-20 left-4 w-64 lg:block z-20">
            <TableOfContents sortedLessonOrder={sortedLessonOrder} />
          </aside>

          {/* Main Content */}
          <main className="ml-0 mt-44 sm:mt-40 md:mt-32">
            <div className="bg-sky-950">{children}</div>
          </main>
        </div>
      </>
    );
  } catch (error) {
    console.error("Unexpected error in layout:", error);
    return <div className="text-red-500">An unexpected error occurred.</div>;
  }
};

export default Layout;

---
File Path: app/members/code/[slug]/page.tsx
// File Path: app/members/code/[slug]/page.tsx

import React from "react";
import ReactMarkdown from "react-markdown";
import "highlight.js/styles/github-dark.css"; // Use your preferred Highlight.js theme
import CodeBlock from "@/components/CodeBlock"; // Ensure this component is correctly implemented
import { cookiesClient } from "@/utils/amplifyServerUtils";
import { LessonContent, Link } from "@/types/LessonContent"; // Ensure this type is correctly defined

/**
 * PageProps Interface
 * -------------------
 * Defines the structure of the route parameters passed to the page component.
 */
interface PageProps {
  params: {
    slug: string;
  };
}

/**
 * LessonPage Component
 * --------------------
 * Renders a lesson page based on the provided slug. It fetches the lesson content from the backend,
 * displays the documentation as formatted Markdown, renders code snippets with TypeScript syntax highlighting,
 * and displays any relevant lesson links.
 * 
 * @param {PageProps} props - The component props containing the route parameter `slug`.
 * @returns {Promise<JSX.Element>} The rendered lesson page component.
 */
const LessonPage: React.FC<PageProps> = async ({ params }) => {
  const { slug } = params;

  try {
    // Fetch the lesson data based on the slug
    const { data: lessons, errors } = await cookiesClient.models.LessonContent.list({
      filter: { slug: { eq: slug } },
    });

    // Handle errors or missing lessons
    if (errors || !lessons || lessons.length === 0) {
      console.error("Error fetching lessons:", errors);
      return <div className="text-red-500">Error loading lesson.</div>;
    }

    // Normalize the lesson data for rendering
    const lessonData = lessons[0];
    const lesson: LessonContent = {
      id: lessonData.id,
      title: lessonData.title,
      slug: lessonData.slug,
      code: lessonData.code || null, // Ensure code is either a string or null
      docs: lessonData.docs,
      isOrdered: lessonData.isOrdered,
      orderIndex: lessonData.orderIndex || null,
      links: (lessonData.links || [])
        .filter((link): link is Link => link !== null) // Filter out null values
        .map((link) => ({
          text: link.text || "", // Default to an empty string if text is null
          url: link.url || "", // Default to an empty string if URL is null
        })),
    };

    return (
      <main className="text-sm text-left">
        <div className="p-1 flex flex-col lg:flex-row gap-2">
          {/* Documentation Section */}
          <section className="lg:w-2/5">
            <div className="lg:fixed lg:top-32 lg:left-0 lg:h-[calc(100vh-8rem)] lg:w-2/5 p-4 m-1 bg-gradient-to-br from-sky-950 to-slate-950 rounded-lg overflow-y-auto">
              <ReactMarkdown className="whitespace-pre-wrap">
                {lesson.docs}
              </ReactMarkdown>

              {/* Links Section */}
              {lesson.links.length > 0 && (
                <div className="mt-4">
                  <h3 className="text-white font-semibold mb-2">Related Links:</h3>
                  <ul className="list-disc list-inside text-blue-400">
                    {lesson.links.map((link, index) => (
                      <li key={index}>
                        <a
                          href={link.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="hover:underline"
                        >
                          {link.text || link.url}
                        </a>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </section>

          {/* Code Section */}
          <section className="lg:w-3/5 p-2 bg-black rounded-lg lg:ml-auto">
            {lesson.code && <CodeBlock code={lesson.code} language="typescript" />}
          </section>
        </div>
      </main>
    );
  } catch (error) {
    console.error("Unexpected error:", error);
    return <div className="text-red-500">An unexpected error occurred.</div>;
  }
};

export default LessonPage;

---
File Path: components/LessonNavigationLinks.tsx
/**
 * File Path: app/members/code/[slug]/LessonNavigationLinks.tsx
 * 
 * Lesson Navigation Links Component
 * ---------------------------------
 * This component renders navigation links for previous and next lessons.
 * It ensures a clear and accessible layout for lesson progression, 
 * with appropriate icons indicating the direction of navigation.
 */

import React from "react";
import Link from "next/link";
import { ArrowLeftIcon, ArrowRightIcon } from "@heroicons/react/24/outline";

/**
 * LessonNavigationLinksProps Interface
 * ------------------------------------
 * Defines the structure of the props passed to the `LessonNavigationLinks` component.
 * It includes optional `prevLesson` and `nextLesson` objects containing the slug and title.
 */
interface LessonNavigationLinksProps {
  prevLesson?: { slug: string; title: string }; // Optional previous lesson
  nextLesson?: { slug: string; title: string }; // Optional next lesson
}

/**
 * LessonNavigationLinks Component
 * -------------------------------
 * Renders navigation links for navigating between lessons. If a previous or next lesson is available,
 * a clickable link is rendered, styled as a button with directional arrows and lesson titles.
 * 
 * @param {LessonNavigationLinksProps} props - The props containing previous and next lesson information.
 * @returns {JSX.Element} The rendered component with navigation links.
 */
const LessonNavigationLinks: React.FC<LessonNavigationLinksProps> = ({
  prevLesson,
  nextLesson,
}) => (
  <div className="section-container mt-8 flex justify-around text-lg font-bold">
    {/* Previous Lesson Link */}
    {prevLesson && (
      <Link href={`/members/code/${prevLesson.slug}`} aria-label={`Go to previous lesson: ${prevLesson.title}`}>
        <div className="bg-green-900 p-2 px-4 text-xs rounded-lg shadow-lg flex items-center">
          <ArrowLeftIcon className="size-8 mr-2" />
          {prevLesson.title}
        </div>
      </Link>
    )}
    
    {/* Next Lesson Link */}
    {nextLesson && (
      <Link href={`/members/code/${nextLesson.slug}`} aria-label={`Go to next lesson: ${nextLesson.title}`}>
        <div className="bg-green-900 p-2 text-xs rounded-lg shadow-lg flex items-center">
          {nextLesson.title}
          <ArrowRightIcon className="size-8 ml-2" />
        </div>
      </Link>
    )}
  </div>
);

export default LessonNavigationLinks;

---
File Path: components/AllLessonsList.tsx
"use client";

/**
 * File Path: @/components/AllLessonsList.tsx
 * 
 * AllLessonsList Component
 * ------------------------
 * Renders a searchable list of all lessons from the `LessonContent` model.
 * Allows selection of an item for viewing or editing, and integrates with Amplify
 * to fetch data while utilizing toast notifications for error handling.
 */

import React, { useState, useEffect, useContext } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext";

// Generate the Amplify client with the schema
const client = generateClient<Schema>();

/**
 * LessonData Interface
 * --------------------
 * Represents the structure of a lesson fetched from the `LessonContent` model.
 */
interface LessonData {
  id: string;   // Unique identifier for the lesson
  type: string; // The type of the lesson (e.g., tutorial, guide)
  title: string; // The title of the lesson
  docs: string; // The documentation content of the lesson
  code?: string; // Optional code content associated with the lesson
  slug: string;  // URL-friendly identifier for the lesson
}

/**
 * AllLessonsListProps Interface
 * -----------------------------
 * Defines the props expected by the `AllLessonsList` component.
 *
 * @interface AllLessonsListProps
 * @property {(id: string | null) => void} onSelectItem - Callback function to handle selection of a lesson item for viewing or editing.
 */
interface AllLessonsListProps {
  onSelectItem: (id: string | null) => void; // Callback for selecting a lesson
}

/**
 * AllLessonsList Component
 * ------------------------
 * Displays a searchable list of all lessons from the `LessonContent` model.
 * Provides filtering functionality based on user input and utilizes toast notifications
 * for displaying any errors encountered during data fetching.
 *
 * @param {AllLessonsListProps} props - The component props.
 * @returns {JSX.Element} The rendered component displaying a list of lessons.
 */
const AllLessonsList: React.FC<AllLessonsListProps> = ({ onSelectItem }) => {
  const [lessons, setLessons] = useState<LessonData[]>([]); // State for storing all lessons
  const [filteredLessons, setFilteredLessons] = useState<LessonData[]>([]); // State for filtered lessons based on search
  const [searchTerm, setSearchTerm] = useState<string>(""); // State for managing the search term input
  const { addToast } = useContext<ToastContextType>(ToastContext); // Access the toast context

  /**
   * Fetches all lessons from the `LessonContent` model and normalizes the data.
   * If errors are encountered, a toast notification is displayed.
   */
  useEffect(() => {
    const fetchLessons = async () => {
      const { data, errors } = await client.models.LessonContent.list();

      if (errors && errors.length > 0) {
        addToast({ messageType: "error", message: "Failed to fetch lessons." });
        console.error("Fetch errors:", errors);
      } else {
        // Normalize the lesson data
        const normalizedData = (data || []).map((lesson) => ({
          ...lesson,
          code: lesson.code || undefined, // Normalize code field
        }));

        setLessons(normalizedData);
        setFilteredLessons(normalizedData); // Initialize filtered lessons with all lessons
      }
    };

    fetchLessons();
  }, [addToast]);

  /**
   * Handles changes in the search input field and filters the lessons accordingly.
   * Lessons can be filtered by title, type, or slug.
   *
   * @param {React.ChangeEvent<HTMLInputElement>} event - The input change event for the search field.
   */
  const handleSearch = (event: React.ChangeEvent<HTMLInputElement>) => {
    const term = event.target.value.toLowerCase();
    setSearchTerm(term);

    // Perform filtering when the search term is at least 3 characters long
    if (term.length >= 3) {
      setFilteredLessons(
        lessons.filter(
          (lesson) =>
            lesson.title.toLowerCase().includes(term) ||
            lesson.type.toLowerCase().includes(term) ||
            lesson.slug.toLowerCase().includes(term)
        )
      );
    } else {
      setFilteredLessons(lessons); // Reset to all lessons if the search term is less than 3 characters
    }
  };

  return (
    <div className="bg-black bg-opacity-70 rounded-lg w-full">
      <div className="flex p-2 flex-col md:flex-row md:justify-between md:items-center">
        <h2 className="heading text-lg mb-2 md:mb-0">All Lessons</h2>
        {/* Search Input */}
        <input
          type="text"
          value={searchTerm}
          onChange={handleSearch}
          placeholder="Search lessons..."
          aria-label="Search lessons by title, type, or slug"
          className="form-input max-w-sm md:mt-0 md:ml-4 p-2 rounded"
        />
      </div>
      {/* List of Lessons */}
      <div className="h-fit overflow-y-auto">
        <ul className="text-sm mt-4 ml-6">
          {filteredLessons.map((lesson) => (
            <li
              key={lesson.id}
              className="my-1 py-1 cursor-pointer text-blue-100 hover:text-blue-50"
              onClick={() => onSelectItem(lesson.id)}
              aria-label={`Select lesson: ${lesson.title}`}
            >
              {lesson.title} ({lesson.type})
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default AllLessonsList;

---
File Path: components/ConfigureAmplify.tsx
"use client";

/**
 * File Path: @/components/ConfigureAmplifyClientSide.tsx
 *
 * ConfigureAmplifyClientSide Component
 * -------------------------------------
 * This component is responsible for configuring AWS Amplify on the client side with the SSR (Server-Side Rendering) option enabled.
 * It imports Amplify configuration from a pre-defined JSON file (`amplify_outputs.json`) and applies the configuration globally.
 * 
 * Note: This component does not render any UI elements, it only handles configuration logic.
 */

import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';

// Configure Amplify with server-side rendering (SSR) enabled
Amplify.configure(outputs, { ssr: true });

/**
 * ConfigureAmplifyClientSide Component
 * ------------------------------------
 * A functional component that configures AWS Amplify for client-side usage.
 * It returns `null` as it does not render any visual output.
 *
 * @returns {null} - The component does not return any visible UI.
 */
export default function ConfigureAmplifyClientSide(): null {
  return null;
}

---
File Path: components/MembersMenu.tsx
"use client";

/**
 * File Path: components/MembersMenu.tsx
 *
 * MembersMenu Component
 * ---------------------
 * This component renders a navigation menu for authenticated members.
 * It provides links to various sections based on user status, includes a slider for controlling the background opacity,
 * and offers account management options such as signing out.
 * The menu can be toggled open or closed and will automatically close when a user clicks outside the menu area.
 */

import Link from "next/link";
import { useAuth } from "@/contexts/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect, useRef } from "react";
import { XCircleIcon } from "@heroicons/react/24/outline";

/**
 * Interface for the MembersMenu component's props.
 *
 * @interface MembersMenuProps
 * @property {number} bgOpacity - The current opacity level of the background image.
 * @property {(event: React.ChangeEvent<HTMLInputElement>) => void} handleOpacityChange - Callback to handle changes in the background opacity.
 * @property {() => void} toggleMenu - Function to toggle the menu's open/close state.
 * @property {boolean} isMenuOpen - Boolean indicating whether the menu is currently open or closed.
 */
interface MembersMenuProps {
  bgOpacity: number;
  handleOpacityChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  toggleMenu: () => void;
  isMenuOpen: boolean;
}

/**
 * MembersMenu Component
 * ---------------------
 * Renders the navigation menu for authenticated members.
 * It displays links, controls background opacity, and offers account management options like signing out.
 * The menu closes automatically when clicking outside of it.
 *
 * @param {MembersMenuProps} props - The props for the component.
 * @returns {JSX.Element} - The rendered MembersMenu component.
 */
export default function MembersMenu({
  bgOpacity,
  handleOpacityChange,
  toggleMenu,
  isMenuOpen,
}: MembersMenuProps): JSX.Element {
  const { user, signOut, isAdmin } = useAuth(); // Access user, signOut function, and admin status from the AuthContext.
  const router = useRouter(); // Get Next.js router for programmatic navigation.
  const menuRef = useRef<HTMLDivElement>(null); // Create a reference to the menu to detect clicks outside it.

  // Define the list of links based on user and admin status.
  const Links = [
    { href: "/", text: "Home" },
    ...(user ? [{ href: "/members/", text: "Members Home" }] : []),
    ...(isAdmin ? [{ href: "/members/admin", text: "Admin" }] : []),
  ];

  /**
   * Handles the user sign-out action, redirects to the home page, and closes the menu.
   */
  const handleSignout = (): void => {
    signOut();
    router.push("/"); // Navigate to home after signing out.
    toggleMenu(); // Close the menu.
  };

  useEffect(() => {
    /**
     * Handles clicks outside the menu. Closes the menu if a click occurs outside of the menu container.
     *
     * @param {MouseEvent} event - The click event.
     */
    const handleClickOutside = (event: MouseEvent): void => {
      if (isMenuOpen && menuRef.current && !menuRef.current.contains(event.target as Node)) {
        toggleMenu(); // Close the menu if the click is outside.
      }
    };

    document.addEventListener("mousedown", handleClickOutside);

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isMenuOpen, toggleMenu]);

  return (
    <div
      ref={menuRef}
      className="z-50 text-left bg-gradient-to-br from-black to-gray-800 via-black fixed top-0 w-full p-6 pt-16 shadow-md"
    >
      {/* Close Menu Button */}
      <button
        className="fixed top-5 right-2 text-white px-4 rounded-lg"
        onClick={toggleMenu}
        aria-label="Close menu"
      >
        <XCircleIcon className="size-7 text-white" />
      </button>

      {/* Navigation Links */}
      <div className="mb-6">
        <nav className="mt-2" aria-label="Members navigation">
          {Links.map((link) => (
            <div key={link.href} className="py-2">
              <Link
                href={link.href}
                className="text-white hover:text-blue-500 mb-2"
                onClick={toggleMenu}
              >
                {link.text}
              </Link>
            </div>
          ))}
        </nav>
      </div>

      {/* Background Opacity Control */}
      <div className="mb-6">
        <label htmlFor="bg-opacity-slider" className="text-white text-xs">
          Background Opacity
        </label>
        <div className="mt-2 max-w-sm">
          <input
            id="bg-opacity-slider"
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={bgOpacity}
            onChange={handleOpacityChange}
            className="form-input w-full"
            aria-label="Adjust background opacity"
          />
        </div>
      </div>

      {/* Account Management */}
      <div>
        <button
          className="member-btn bg-red-600 hover:bg-red-500"
          onClick={handleSignout}
          aria-label="Sign out"
        >
          Sign Out
        </button>
      </div>
    </div>
  );
}

---
File Path: components/CreatePoll.tsx
"use client";

/**
 * File Path: components/CreatePoll.tsx
 *
 * CreatePoll Component
 * --------------------
 * This component provides a form interface for creating a new poll. Users can specify a poll title
 * and up to 10 options. The component integrates with AWS Amplify to store poll data and provides
 * feedback through toast notifications for both successful and unsuccessful operations.
 */

import React, { useState, useContext } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext";

// Generate a client instance for interacting with Amplify data schema.
const client = generateClient<Schema>();

/**
 * CreatePoll Component
 * --------------------
 * Renders a form that allows users to create a new poll with a title and multiple options.
 * Users can add up to 10 options, and the component provides real-time feedback using toast notifications.
 *
 * @component
 * @returns {JSX.Element} - The rendered CreatePoll component.
 */
export default function CreatePoll(): JSX.Element {
  const [title, setTitle] = useState<string>(""); // State to store the poll title.
  const [options, setOptions] = useState<string[]>([""]); // State to store the poll options.

  const { addToast } = useContext<ToastContextType>(ToastContext); // Access toast notifications from context.

  /**
   * addOption Function
   * ------------------
   * Adds a new option input field if there are fewer than 10 options.
   */
  const addOption = (): void => {
    if (options.length < 10) {
      setOptions([...options, ""]);
    } else {
      addToast({
        messageType: "error",
        message: "You can only add up to 10 options.",
      });
    }
  };

  /**
   * handleOptionChange Function
   * ---------------------------
   * Updates the value of a specific poll option based on user input.
   *
   * @param {number} index - The index of the option being modified.
   * @param {string} value - The new value for the option.
   */
  const handleOptionChange = (index: number, value: string): void => {
    const updatedOptions = [...options];
    updatedOptions[index] = value;
    setOptions(updatedOptions);
  };

  /**
   * handleOptionRemove Function
   * ---------------------------
   * Removes a poll option based on the index provided.
   *
   * @param {number} index - The index of the option to be removed.
   */
  const handleOptionRemove = (index: number): void => {
    const updatedOptions = options.filter((_, i) => i !== index);
    setOptions(updatedOptions);
  };

  /**
   * handleSubmit Function
   * ---------------------
   * Validates the poll form fields and submits the poll to the backend.
   * Displays feedback via toast notifications on success or failure.
   */
  const handleSubmit = async (): Promise<void> => {
    if (!title || options.some((option) => !option)) {
      addToast({
        messageType: "error",
        message: "Please fill in all fields.",
      });
      return;
    }

    try {
      const { errors } = await client.models.Poll.create({
        title,
        options,
        createdAt: new Date().toISOString(),
        status: "draft", // The initial status of a newly created poll is "draft".
      });

      if (errors) {
        addToast({
          messageType: "error",
          message: "Failed to create poll.",
        });
        console.error("Errors:", errors);
      } else {
        addToast({
          messageType: "success",
          message: "Poll created successfully.",
        });
        setTitle("");
        setOptions([""]); // Reset form fields after successful creation.
      }
    } catch (err) {
      addToast({
        messageType: "error",
        message: "An unexpected error occurred.",
      });
      console.error("Unexpected error:", err);
    }
  };

  return (
    <section className="section-container p-2">
      <header>
        <h1 className="heading">Create a New Poll</h1>
      </header>
      <div className="bg-black bg-opacity-70 p-4 rounded-lg w-full">
        <div className="mb-4 w-full">
          <label htmlFor="poll-title" className="block text-white text-xs text-left">
            Poll Title
          </label>
          <input
            id="poll-title"
            className="form-input"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="Enter poll title"
            aria-label="Poll Title"
          />
        </div>
        <div className="mb-4 w-full">
          <label className="block text-white text-xs text-left">Poll Options</label>
          {options.map((option, index) => (
            <div key={index} className="flex items-center mb-2">
              <input
                className="form-input"
                type="text"
                value={option}
                onChange={(e) => handleOptionChange(index, e.target.value)}
                placeholder={`Option ${index + 1}`}
                aria-label={`Poll Option ${index + 1}`}
              />
              <button
                className="btn btn-secondary ml-2"
                type="button"
                onClick={() => handleOptionRemove(index)}
                aria-label={`Remove Option ${index + 1}`}
              >
                Delete
              </button>
            </div>
          ))}
        </div>
        <div className="flex justify-between mt-4">
          {options.length < 10 && (
            <button
              className="btn bg-green-600 hover:bg-green-700 border border-green-500 text-white"
              type="button"
              onClick={addOption}
              aria-label="Add Poll Option"
            >
              Add Option
            </button>
          )}
          <button
            className="btn btn-primary"
            type="button"
            onClick={handleSubmit}
            aria-label="Create Poll"
          >
            Create Poll
          </button>
        </div>
      </div>
    </section>
  );
}

---
File Path: components/CurrentPoll.tsx
"use client";

/**
 * File Path: components/CurrentPoll.tsx
 *
 * CurrentPoll Component
 * ---------------------
 * This component fetches and displays the currently active poll along with vote counts for each option.
 * It handles real-time updates through subscriptions to ensure the vote count is always current.
 */

import React, { useState, useEffect } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

type Poll = Schema["Poll"]["type"];

// Generate a client instance for interacting with the data schema
const client = generateClient<Schema>();

/**
 * CurrentPoll Component
 * ---------------------
 * Displays the currently active poll with vote counts for each option, with real-time updates.
 *
 * @component
 * @returns {JSX.Element} The rendered component displaying the active poll and vote counts.
 */
export default function CurrentPoll(): JSX.Element {
  const [poll, setPoll] = useState<Poll | null>(null); // State for the active poll
  const [voteCounts, setVoteCounts] = useState<Record<string, number>>({}); // State for the vote counts per option
  const [loading, setLoading] = useState<boolean>(true); // State for tracking loading status
  const [error, setError] = useState<string | null>(null); // State for error messages

  useEffect(() => {
    /**
     * Fetches the currently active poll from the backend.
     */
    const fetchActivePoll = async (): Promise<void> => {
      try {
        const { data: polls, errors } = await client.models.Poll.list({
          filter: { status: { eq: "active" } },
        });

        if (errors || !polls || polls.length === 0) {
          setError("No active poll found.");
          console.error("Errors:", errors);
        } else {
          setPoll(polls[0]);
        }
      } catch (err) {
        setError("An unexpected error occurred while fetching the active poll.");
        console.error("Unexpected error:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchActivePoll();
  }, []);

  useEffect(() => {
    /**
     * Fetches the vote counts for the current poll and sets up a real-time subscription for updates.
     */
    const fetchVoteCounts = async (): Promise<void> => {
      if (!poll) return;

      try {
        const { data: votes, errors } = await client.models.Vote.list({
          filter: { pollId: { eq: poll.id } },
        });

        if (errors) {
          setError("Failed to fetch votes.");
          console.error("Errors:", errors);
        } else {
          const counts: Record<string, number> = {};
          poll.options.forEach((option) => {
            if (option) {
              counts[option] = votes.filter((vote) => vote.option === option).length;
            }
          });
          setVoteCounts(counts);
        }
      } catch (err) {
        setError("An unexpected error occurred while fetching votes.");
        console.error("Unexpected error:", err);
      }
    };

    fetchVoteCounts();

    // Subscribe to real-time vote updates
    let subscription: { unsubscribe: () => void };
    if (poll) {
      subscription = client.models.Vote.onCreate({
        filter: { pollId: { eq: poll.id } },
      }).subscribe({
        next: (newVote) => {
          setVoteCounts((prevCounts) => ({
            ...prevCounts,
            [newVote.option]: (prevCounts[newVote.option] || 0) + 1,
          }));
        },
        error: (error) => console.error("Error in vote subscription:", error),
      });
    }

    // Cleanup the subscription on component unmount
    return () => {
      if (subscription) subscription.unsubscribe();
    };
  }, [poll]);

  if (loading) {
    return <div>Loading current poll...</div>;
  }

  if (error || !poll) {
    return <div>Error: {error || "No active poll available."}</div>;
  }

  return (
    <section className="section-container pb-4 sm:p-4">
      <header className="heading">Current Poll</header>
      <article className="text-xs mb-2 bg-black bg-opacity-70 pb-2 shadow-lg rounded-lg overflow-hidden">
        <div className="p-4">
          <h2 className="text-lg font-semibold pb-2">{poll.title}</h2>
          <table className="w-full text-left table-auto">
            <thead>
              <tr>
                <th className="p-2">Option</th>
                <th className="p-2">Votes</th>
              </tr>
            </thead>
            <tbody>
              {poll.options.map((option, index) => (
                <tr key={index}>
                  <td className="p-2">{option}</td>
                  <td className="p-2">{voteCounts[option as string] || 0}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </article>
    </section>
  );
}

---
File Path: components/Background.tsx
"use client";

import { motion } from "framer-motion";
import { AnimatedBackground } from "@/components/AnimatedBackground";

/**
 * Background Component
 * --------------------
 * This component serves as a wrapper for the application's animated background,
 * handling the transition effects between route changes using Framer Motion.
 * It controls the background's opacity and ensures a smooth animation experience
 * as users navigate through different routes in the application.
 *
 * @component
 * @returns {JSX.Element} The animated background with route transition effects.
 */
export function Background(): JSX.Element {
  /**
   * Animation variants for controlling the background opacity during route transitions.
   * - `enter`: Initial state with reduced opacity when the component first renders.
   * - `active`: Gradual transition to full opacity over 25 seconds, providing a smooth fade-in effect.
   * - `exit`: Reverse transition to reduced opacity when the route changes or the component unmounts.
   */
  const backgroundVariants = {
    enter: { opacity: 0.5 },
    active: { opacity: 1, transition: { duration: 25, ease: "easeInOut" } },
    exit: { opacity: 0.5, transition: { duration: 25, ease: "easeInOut" } },
  };

  return (
    <motion.div
      initial="enter"
      animate="active"
      exit="exit"
      variants={backgroundVariants}
      className="fixed inset-0 -z-50 overflow-hidden h-screen w-screen"
    >
      {/* Render the background animation */}
      <AnimatedBackground />
    </motion.div>
  );
}

---
File Path: components/LessonOrder.tsx
"use client";

import React, { useState, useEffect, useContext } from "react";
import { Reorder } from "framer-motion";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext";

// Generate the Amplify client
const client = generateClient<Schema>();

/**
 * LessonItem Interface
 * --------------------
 * Defines the structure of a lesson item, including its unique ID, title, slug, and ordering status.
 */
interface LessonItem {
  id: string;
  title: string;
  slug: string;
  isOrdered: boolean;
}

/**
 * LessonOrder Component
 * ---------------------
 * This component allows administrators to manage the order of lessons.
 * It fetches lessons from the `LessonContent` model, displays unordered lessons,
 * and allows users to reorder lessons using drag-and-drop functionality.
 * Changes are saved back to the `LessonContent` model in the database.
 * 
 * @component
 * @returns {JSX.Element} The rendered LessonOrder component.
 */
export default function LessonOrder(): JSX.Element {
  const [unorderedItems, setUnorderedItems] = useState<LessonItem[]>([]);
  const [orderedItems, setOrderedItems] = useState<LessonItem[]>([]);
  const { addToast } = useContext<ToastContextType>(ToastContext);

  /**
   * Fetch lesson items from the `LessonContent` model, separating ordered and unordered items.
   */
  useEffect(() => {
    const fetchItems = async () => {
      try {
        const { data: lessons } = await client.models.LessonContent.list();
  
        if (lessons) {
          const unordered = lessons
            .filter(item => !item.isOrdered)
            .map(item => ({
              id: item.id,
              title: item.title,
              slug: item.slug,
              isOrdered: item.isOrdered,
            }));
  
          const ordered = lessons
            .filter(item => item.isOrdered)
            .sort((a, b) => (a.orderIndex ?? 0) - (b.orderIndex ?? 0))
            .map(item => ({
              id: item.id,
              title: item.title,
              slug: item.slug,
              isOrdered: item.isOrdered,
            }));
  
          setUnorderedItems(unordered);
          setOrderedItems(ordered);
        }
      } catch (err) {
        console.error("Error fetching lesson items:", err);
        addToast({ messageType: "error", message: "Failed to fetch lesson items." });
      }
    };
  
    fetchItems();
  }, [addToast]);

  /**
   * Handle saving the updated lesson order to the backend.
   */
  const handleSaveOrder = async (): Promise<void> => {
    try {
      const sortedItems = [...orderedItems].sort((a, b) => {
        return orderedItems.indexOf(a) - orderedItems.indexOf(b);
      });
  
      const results = await Promise.all(
        sortedItems.map((item, index) =>
          client.models.LessonContent.update({
            id: item.id,
            isOrdered: true,
            orderIndex: index,
          })
        )
      );
  
      console.log("Saved order:", results);
      addToast({ messageType: "success", message: "Lesson order saved successfully!" });
    } catch (err) {
      console.error("Error saving lesson order:", err);
      addToast({ messageType: "error", message: "Failed to save lesson order." });
    }
  };

  return (
    <section className="bg-black bg-opacity-70 p-4 rounded-lg w-full mb-4">
      <div className="flex flex-col md:flex-row md:justify-between gap-8">
        {/* Unordered Lessons Section */}
        <div className="w-full md:w-1/2">
          <h2 className="text-lg font-semibold mb-2">Unordered Lessons</h2>
          <ul className="text-sm space-y-2 overflow-scroll max-h-[50vh]" role="list">
            {unorderedItems.map(item => (
              <li
                key={item.id}
                className="bg-gray-800 hover:bg-gray-700 text-white p-2 rounded cursor-pointer"
                onClick={() => {
                  setOrderedItems([...orderedItems, item]);
                  setUnorderedItems(unorderedItems.filter(unorderedItem => unorderedItem.id !== item.id));
                }}
              >
                {item.title}
              </li>
            ))}
          </ul>
        </div>

        {/* Ordered Lessons Section */}
        <div className="w-full md:w-1/2">
          <h2 className="text-lg font-semibold mb-2">Ordered Lessons</h2>
          <Reorder.Group
            as="ul"
            axis="y"
            values={orderedItems}
            onReorder={setOrderedItems}
            className="text-sm space-y-2 overflow-scroll max-h-[50vh]"
            role="list"
          >
            {orderedItems.map(item => (
              <Reorder.Item
                key={item.id}
                value={item}
                className="bg-green-800 hover:bg-green-700 text-white p-2 rounded cursor-move"
              >
                {item.title}
              </Reorder.Item>
            ))}
          </Reorder.Group>
          {orderedItems.length > 0 && (
            <button
              className="btn btn-primary mt-4 w-full"
              onClick={handleSaveOrder}
            >
              Save Changes
            </button>
          )}
        </div>
      </div>
    </section>
  );
}

---
File Path: components/ListPolls.tsx
/**
 * File Path: components/ListPolls.tsx
 * 
 * List Polls Component
 * --------------------
 * This file defines the ListPolls component, which is responsible for displaying a list of polls,
 * allowing users to view poll details, activate polls, and delete polls. The component integrates
 * with AWS Amplify for data fetching, real-time updates, and state management.
 */

"use client";

import React, { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

/**
 * Type definition for the Poll object from the Amplify data schema.
 */
type Poll = Schema["Poll"]["type"];

// Generate a client instance for interacting with the Amplify data schema.
const client = generateClient<Schema>();

/**
 * AccordionProps Interface
 * ------------------------
 * Defines the props for the Accordion component that displays individual poll details.
 */
interface AccordionProps {
  poll: Poll; // The poll object containing its details.
  expanded: string | null; // ID of the currently expanded poll (if any).
  setExpanded: React.Dispatch<React.SetStateAction<string | null>>; // Function to set the expanded poll ID.
  handleActivatePoll: (pollId: string) => Promise<void>; // Function to handle poll activation.
  handleDeletePoll: (pollId: string) => Promise<void>; // Function to handle poll deletion.
}

/**
 * Subscription Interface
 * ----------------------
 * Defines the structure for a subscription object with an unsubscribe method.
 */
interface Subscription {
  unsubscribe: () => void;
}

/**
 * Accordion Component
 * -------------------
 * Renders an accordion section for a single poll, including poll details, vote counts, and actions.
 * 
 * @component
 * @param {AccordionProps} props - The props for the component.
 * @returns {JSX.Element} The rendered Accordion component.
 */
const Accordion: React.FC<AccordionProps> = ({
  poll,
  expanded,
  setExpanded,
  handleActivatePoll,
  handleDeletePoll,
}) => {
  const isOpen = poll.id === expanded; // Check if this accordion is open.
  const isActive = poll.status === "active"; // Check if this poll is active.

  const [voteCounts, setVoteCounts] = useState<Record<string, number>>({}); // State to store the vote counts for each option.

  useEffect(() => {
    /**
     * fetchVotes Function
     * -------------------
     * Fetches the votes for this poll and updates the vote counts state.
     */
    const fetchVotes = async () => {
      const { data: votes, errors } = await client.models.Vote.list({
        filter: { pollId: { eq: poll.id } },
      });

      if (!errors) {
        const counts: Record<string, number> = {};
        poll.options.forEach((option) => {
          if (option) {
            counts[option] = votes.filter(
              (vote) => vote.option === option
            ).length;
          }
        });
        setVoteCounts(counts);
      } else {
        console.error("Failed to fetch votes:", errors);
      }
    };

    if (isOpen) {
      fetchVotes();
    }

    // Subscribe to real-time vote updates
    let subscription: Subscription;
    if (isOpen || isActive) {
      subscription = client.models.Vote.onCreate({
        filter: { pollId: { eq: poll.id } },
      }).subscribe({
        next: (newVote) => {
          setVoteCounts((prevCounts) => ({
            ...prevCounts,
            [newVote.option]: (prevCounts[newVote.option] || 0) + 1,
          }));
        },
        error: (error) => console.error("Error in subscription:", error),
      });
    }

    // Cleanup the subscription on component unmount
    return () => {
      if (subscription) subscription.unsubscribe();
    };
  }, [isOpen, isActive, poll.id, poll.options]);

  return (
    <div className="text-xs mb-2 bg-black bg-opacity-70 pb-2 shadow-lg rounded-lg overflow-hidden">
      <motion.header
        className="cursor-pointer p-4 flex items-center justify-between"
        initial={false}
        onClick={() => setExpanded(isOpen ? null : poll.id)}
        role="button"
        aria-expanded={isOpen}
      >
        <div className="flex flex-col w-full">
          <div className="flex items-center justify-between">
            <button
              className={`w-14 h-14 p-2 rounded-lg ${
                isActive
                  ? "bg-blue-400 text-blue-50 border border-blue-200"
                  : "bg-blue-800 text-blue-700 border border-blue-600"
              } bg-opacity-75`}
              onClick={(e) => {
                e.stopPropagation();
                handleActivatePoll(poll.id);
              }}
              aria-label={`Activate poll ${poll.title}`}
            >
              Active
            </button>
            <div className="flex flex-col flex-grow pl-4">
              <div className="flex items-center justify-between">
                <span>{poll.title}</span>
                <div className="flex space-x-4">
                  <time dateTime={new Date(poll.createdAt).toISOString()}>
                    {new Date(poll.createdAt).toLocaleDateString()}
                  </time>
                </div>
              </div>
              <div className="flex mt-2 space-x-2">
                <button
                  className="p-2 px-4 bg-red-600 text-white rounded"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDeletePoll(poll.id);
                  }}
                  aria-label={`Delete poll ${poll.title}`}
                >
                  Delete
                </button>
                <button
                  className="p-2 px-4 bg-blue-600 text-white rounded"
                  onClick={(e) => {
                    e.stopPropagation();
                    setExpanded(isOpen ? null : poll.id);
                  }}
                  aria-label={isOpen ? `Collapse details of ${poll.title}` : `Expand details of ${poll.title}`}
                >
                  {isOpen ? "Show Less" : "Show More"}
                </button>
              </div>
            </div>
          </div>
        </div>
      </motion.header>
      <AnimatePresence initial={false}>
        {isOpen && (
          <motion.section
            key="content"
            initial="collapsed"
            animate="open"
            exit="collapsed"
            variants={{
              open: { opacity: 1, height: "auto" },
              collapsed: { opacity: 0, height: 0 },
            }}
            transition={{ duration: 0.8, ease: [0.04, 0.62, 0.23, 0.98] }}
          >
            <div className="w-full">
              <div className="text-lg font-semibold pb-2">Poll Details</div>
              <div className="grid grid-cols-2 gap-2 text-left pb-3">
                <div className="font-bold text-center">Title</div>
                <div>{poll.title}</div>

                <div className="font-bold text-center">Status</div>
                <div>{poll.status}</div>

                <div className="font-bold text-center">Created</div>
                <time dateTime={new Date(poll.createdAt).toISOString()}>
                  {new Date(poll.createdAt).toLocaleString()}
                </time>
              </div>
              <table className="w-full text-left table-auto">
                <thead>
                  <tr>
                    <th className="p-2">Option</th>
                    <th className="p-2">Votes</th>
                  </tr>
                </thead>
                <tbody>
                  {poll.options.map((option, index) => (
                    <tr key={index}>
                      <td className="p-2">{option}</td>
                      <td className="p-2">
                        {voteCounts[option as string] || 0}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </motion.section>
        )}
      </AnimatePresence>
    </div>
  );
};

/**
 * ListPolls Component
 * -------------------
 * Displays a list of polls and allows the user to expand individual polls for more details, 
 * activate polls, delete polls, and subscribe to real-time updates for votes.
 * 
 * @component
 * @returns {JSX.Element} The rendered ListPolls component.
 */
export default function ListPolls(): JSX.Element {
  const [polls, setPolls] = useState<Poll[]>([]); // State to store the list of polls.
  const [loading, setLoading] = useState<boolean>(true); // State to track loading status.
  const [error, setError] = useState<string | null>(null); // State to store any error messages.
  const [expanded, setExpanded] = useState<string | null>(null); // State to track the expanded accordion section.

  useEffect(() => {
    /**
     * fetchPolls Function
     * -------------------
     * Fetches the list of polls from the backend and sorts them by status and creation date.
     */
    const fetchPolls = async (): Promise<void> => {
      try {
        const { data: pollList, errors } = await client.models.Poll.list();

        if (errors) {
          setError("Failed to fetch polls");
          console.error("Errors:", errors);
        } else {
          const sortedPolls = pollList.sort((a, b) => {
            if (a.status === "active") return -1;
            if (b.status === "active") return 1;
            return (
              new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
            );
          });
          setPolls(sortedPolls);
        }
      } catch (err) {
        setError("An unexpected error occurred");
        console.error("Unexpected error:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchPolls();

    // Subscribe to new poll creations
    const subscription = client.models.Poll.onCreate().subscribe({
      next: (newPoll) => {
        setPolls((prevPolls) => {
          const updatedPolls = [newPoll, ...prevPolls];
          return updatedPolls.sort((a, b) => {
            if (a.status === "active") return -1;
            if (b.status === "active") return 1;
            return (
              new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
            );
          });
        });
      },
      error: (error) => console.error("Error in subscription:", error),
    });

    // Cleanup subscription on component unmount
    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => {
    // Find the active poll and subscribe to it
    const activePoll = polls.find((poll) => poll.status === "active");

    if (activePoll) {
      const subscription = client.models.Vote.onCreate({
        filter: { pollId: { eq: activePoll.id } },
      }).subscribe({
        next: () => {
          setPolls((prevPolls) =>
            prevPolls.map((poll) => {
              if (poll.id === activePoll.id) {
                return {
                  ...poll,
                  // voteCounts are handled within the Accordion component.
                };
              }
              return poll;
            })
          );
        },
        error: (error) => console.error("Error in vote subscription:", error),
      });

      return () => subscription.unsubscribe();
    }
  }, [polls]);

  /**
   * handleActivatePoll Function
   * ---------------------------
   * Activates a specific poll and deactivates all others.
   * 
   * @param {string} pollId - The ID of the poll to activate.
   */
  const handleActivatePoll = async (pollId: string): Promise<void> => {
    try {
      // Step 1: Set all polls to inactive
      const { data: polls, errors } = await client.models.Poll.list();
      if (errors) {
        console.error("Failed to fetch polls for deactivation:", errors);
        return;
      }
      await Promise.all(
        polls.map(async (poll) => {
          if (poll.id !== pollId && poll.status === "active") {
            await client.models.Poll.update({
              id: poll.id,
              status: "inactive",
            });
          }
        })
      );

      // Step 2: Set the selected poll to active
      await client.models.Poll.update({ id: pollId, status: "active" });

      // Step 3: Update state
      setPolls((prevPolls) =>
        prevPolls.map((poll) =>
          poll.id === pollId
            ? { ...poll, status: "active" }
            : { ...poll, status: "inactive" }
        )
      );
    } catch (err) {
      console.error("Failed to activate poll:", err);
    }
  };

  /**
   * handleDeletePoll Function
   * -------------------------
   * Deletes a specific poll and its associated votes.
   * 
   * @param {string} pollId - The ID of the poll to delete.
   */
  const handleDeletePoll = async (pollId: string): Promise<void> => {
    try {
      // Fetch all votes associated with the poll
      const { data: votes, errors } = await client.models.Vote.list({
        filter: { pollId: { eq: pollId } },
      });

      if (errors) {
        console.error("Failed to fetch associated votes:", errors);
        return;
      }

      // Delete each vote individually
      if (votes) {
        await Promise.all(
          votes.map(async (vote) => {
            await client.models.Vote.delete({ id: vote.id });
          })
        );
      }

      // Delete the poll
      await client.models.Poll.delete({ id: pollId });

      // Remove the poll from the state
      setPolls((prevPolls) => prevPolls.filter((poll) => poll.id !== pollId));
    } catch (err) {
      console.error("Failed to delete poll:", err);
    }
  };

  if (loading) {
    return <div>Loading polls...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <section className="section-container p-2">
      <h1 className="heading">Current Polls</h1>
      {polls.map((poll) => (
        <Accordion
          key={poll.id}
          poll={poll}
          expanded={expanded}
          setExpanded={setExpanded}
          handleActivatePoll={handleActivatePoll}
          handleDeletePoll={handleDeletePoll}
        />
      ))}
    </section>
  );
}

---
File Path: components/AuthenticatedNavBar.tsx
/**
 * File Path: components/AuthenticatedNavBar.tsx
 * 
 * AuthenticatedNavBar Component
 * -----------------------------
 * Renders a navigation bar based on the user's role and the current URL path.
 * This component dynamically displays either the Members Menu or the Admin Menu 
 * depending on the pathname.
 * 
 * The component ensures proper accessibility and SEO by using semantic HTML elements.
 * The styling changes dynamically based on the active link.
 */

"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";

/**
 * Interface representing the structure of a navigation link.
 */
interface NavLink {
  href: string;  // URL the link points to
  label: string; // Display label for the link
}

// Define navigation links for both members and admin.
const membersNavLinks: NavLink[] = [
  { href: "/members", label: "Members Home" },
  { href: "/members/code", label: "Code" },
];

const adminNavLinks: NavLink[] = [
  { href: "/members/admin", label: "Admin Home" },
  { href: "/members/admin/users", label: "Manage Users" },
  { href: "/members/admin/polls", label: "Manage Polls" },
  { href: "/members/admin/code", label: "Manage Content" },
  { href: "/members/admin/messaging", label: "Messaging" },
];

/**
 * AuthenticatedNavBar Component
 * -----------------------------
 * Renders the appropriate navigation bar based on the URL path.
 * It dynamically selects either the Members or Admin navigation menu depending 
 * on the URL, and highlights the active link for visual feedback.
 *
 * @returns {JSX.Element} - The rendered navigation bar component.
 */
export default function AuthenticatedNavBar(): JSX.Element {
  const pathname = usePathname();

  // Determine the correct set of navigation links based on the URL path.
  const navLinks = pathname.startsWith("/members/admin")
    ? adminNavLinks
    : membersNavLinks;

  return (
    <nav 
      aria-label="Authenticated Navigation Bar" 
      className="text-xs lg:text-sm xl:text-base lg:font-extralight lg:space-x-2 xl:space-x-2 mx-1 flex space-around items-center justify-center"
    >
      {navLinks.map((link) => {
        // Check if the current link is active
        const isActive =
          pathname === link.href ||
          (link.href === "/members/code" && pathname.startsWith("/members/code/"));

        return (
          <Link
            key={link.href}
            href={link.href}
            aria-current={isActive ? "page" : undefined} // Accessibility: Indicate current page
            className={`p-2 border rounded ${
              isActive
                ? "text-white border-white" // Active link styles
                : "text-yellow-400 border-0" // Inactive link styles
            } transition-colors duration-200`}
          >
            {link.label}
          </Link>
        );
      })}
    </nav>
  );
}

---
File Path: components/SetLessonStage.tsx
/**
 * File Path: components/SetLessonStage.tsx
 *
 * SetLessonStage Component
 * ------------------------
 * This component is responsible for updating the 'lessonStage' value in localStorage 
 * to reflect the current lesson's slug. The component does not render any UI 
 * and operates entirely through its side effect using the useEffect hook.
 *
 * It ensures the lesson state is preserved across page reloads by storing the slug 
 * in the browser's localStorage.
 */

"use client";

import { useEffect } from 'react';

/**
 * Props interface for SetLessonStage component.
 */
interface SetLessonStageProps {
  /**
   * The slug representing the current lesson stage.
   */
  slug: string;
}

/**
 * SetLessonStage Component
 * ------------------------
 * Updates the 'lessonStage' value in localStorage based on the provided lesson slug.
 * This component is used to track the user's current lesson stage persistently across sessions.
 * 
 * @param {SetLessonStageProps} props - The component props containing the current lesson's slug.
 * @returns {null} This component does not render any visible UI.
 */
const SetLessonStage: React.FC<SetLessonStageProps> = ({ slug }) => {
  useEffect(() => {
    // Ensure window object is available before accessing localStorage
    if (typeof window !== 'undefined') {
      localStorage.setItem('lessonStage', slug);
    }
  }, [slug]);

  return null; // No visible UI
};

export default SetLessonStage;

---
File Path: components/Poll.tsx
/**
 * File Path: components/Poll.tsx
 *
 * Poll Component
 * --------------
 * This component is responsible for rendering the current active poll, 
 * allowing users to vote, and displaying real-time results.
 * It integrates with AWS Amplify to fetch poll data and handle real-time updates.
 */

"use client";

import { useEffect, useState } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { useAuth } from "@/contexts/AuthContext";

// Generate a client instance for interacting with the data schema.
const client = generateClient<Schema>();

/**
 * Poll Component
 * --------------
 * Renders the current active poll, allows users to vote, and displays real-time results.
 * The component fetches data from AWS Amplify and handles state updates when users vote.
 *
 * @component
 * @returns {JSX.Element} The rendered Poll component.
 */
export default function Poll(): JSX.Element {
  const { user } = useAuth(); // Access user details from authentication context.
  const [poll, setPoll] = useState<Schema["Poll"]["type"] | null>(null); // State to store the current poll.
  const [voteCounts, setVoteCounts] = useState<Record<string, number>>({}); // State to store vote counts for each option.
  const [hasVoted, setHasVoted] = useState<boolean>(false); // State to track if the user has already voted.
  const [loading, setLoading] = useState<boolean>(true); // State to track data loading status.
  const [error, setError] = useState<string | null>(null); // State to store error messages.

  useEffect(() => {
    /**
     * fetchPollData
     * -------------
     * Fetches the active poll and its associated votes from the backend.
     * If an active poll is found, it sets the poll state and vote counts.
     * 
     * Handles user vote detection and initializes vote counts for each poll option.
     */
    const fetchPollData = async (): Promise<void> => {
      try {
        const { data: pollList, errors } = await client.models.Poll.list({
          filter: { status: { eq: "active" } },
        });

        if (errors || !pollList || pollList.length === 0) {
          setError("Error fetching poll data.");
          return;
        }

        const activePoll = pollList[0];
        setPoll(activePoll);

        if (!activePoll) return;

        // Fetch all votes for the active poll
        const { data: voteData } = await client.models.Vote.list({
          filter: { pollId: { eq: activePoll.id } },
        });

        // Check if the user has already voted
        const userVote = voteData.find(
          (vote) => vote.userId === user?.username
        );
        if (userVote) {
          setHasVoted(true);
        }

        // Initialize and count votes
        const initialVoteCounts: Record<string, number> = {};
        activePoll.options.forEach((option) => {
          if (option !== null) {
            initialVoteCounts[option] = 0;
          }
        });

        voteData.forEach((vote) => {
          if (vote.option && vote.option in initialVoteCounts) {
            initialVoteCounts[vote.option]++;
          }
        });

        setVoteCounts(initialVoteCounts);
      } catch (error) {
        setError("Error fetching poll data.");
        console.error("Error fetching poll data:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchPollData();
  }, [user]);

  useEffect(() => {
    /**
     * Subscribe to real-time poll updates once the user has voted.
     * 
     * Subscribes to new votes for the current poll, updating the vote counts in real-time.
     */
    if (poll && hasVoted) {
      const subscription = client.models.Vote.onCreate({
        filter: { pollId: { eq: poll.id } },
      }).subscribe({
        next: (data) => {
          const updatedVoteCounts = { ...voteCounts };
          if (data.option && data.option in updatedVoteCounts) {
            updatedVoteCounts[data.option] += 1;
            setVoteCounts(updatedVoteCounts);
          }
        },
        error: (error) => console.error("Error in subscription:", error),
      });

      return () => subscription.unsubscribe();
    }
  }, [poll, hasVoted, voteCounts]);

  /**
   * handleVote
   * ----------
   * Handles the user's vote submission and updates the vote counts optimistically.
   * 
   * @param {string} option - The option the user selects to vote for.
   */
  const handleVote = async (option: string): Promise<void> => {
    if (!hasVoted && option) {
      try {
        await client.models.Vote.create({
          userId: user?.username || "",
          pollId: poll!.id,
          option,
        });

        setHasVoted(true);

        // Optimistically update vote counts
        setVoteCounts((prev) => ({
          ...prev,
          [option]: (prev[option] || 0) + 1,
        }));
      } catch (error) {
        setError("Error casting vote.");
        console.error("Error casting vote:", error);
      }
    }
  };

  if (loading) return <div>Loading active poll...</div>;
  if (error || !poll)
    return <div>{error || "There is no active poll currently"}</div>;

  return (
    <section className="section-container sm:ml-1 md:ml-0 pb-4 sm:p-4 h-min">
      <header className="heading">Current Poll</header>
      <article className="bg-black bg-opacity-70 p-4 rounded-lg">
        <h2 className="text-2xl font-bold mb-4">{poll.title}</h2>
        {hasVoted ? (
          <div className="max-w-md mx-auto">
            <h3 className="text-lg mb-2 text-center">Current Results</h3>
            <ul className="space-y-2 w-full">
              {Object.entries(voteCounts).map(([option, count]) => (
                <li key={option} className="text-sm">
                  <div className="grid grid-cols-3 gap-4">
                    <span className="col-span-2 text-left">{option}</span>
                    <span className="text-left">
                      {count} vote{`${count !== 1 ? "s" : ""}`}
                    </span>
                  </div>
                </li>
              ))}
            </ul>
          </div>
        ) : (
          <div className="space-y-4">
            {poll.options.map((option) => (
              <button
                key={option}
                className="btn btn-primary block w-full"
                onClick={() => handleVote(option as string)}
              >
                {option}
              </button>
            ))}
          </div>
        )}
      </article>
    </section>
  );
}

---
File Path: components/AnimatedBackground.tsx
/**
 * File Path: @/components/AnimatedBackground.tsx
 * 
 * AnimatedBackground Component
 * ----------------------------
 * This component displays an animated grid of colored boxes that change color 
 * at random intervals, creating a dynamic and responsive background. The grid 
 * layout adapts to the window size, with boxes cycling through three colors: 
 * black, blue, and orange. 
 * 
 * The component leverages Framer Motion for smooth animations and ensures 
 * responsiveness by adjusting box sizes based on screen width.
 */

"use client";

import { useEffect, useState } from "react";
import { motion } from "framer-motion";

/**
 * AnimatedBackground Component
 * ----------------------------
 * Renders a responsive, animated background of colored boxes that change color 
 * at random intervals. The grid layout and box sizes adapt to the window's dimensions.
 * 
 * @returns {JSX.Element | null} The rendered AnimatedBackground component, or null 
 * if grid dimensions are not yet ready.
 */
export function AnimatedBackground(): JSX.Element | null {
  /**
   * Defines a type for color states, allowing only values of 0, 1, or 2.
   */
  type ColorState = 0 | 1 | 2;

  // State variables for managing grid dimensions, box size, total boxes, and color states.
  const [boxSize, setBoxSize] = useState<number>(75); // Default size for larger screens.
  const [gridColumns, setGridColumns] = useState<number>(0); // Number of columns in the grid.
  const [gridRows, setGridRows] = useState<number>(0); // Number of rows in the grid.
  const [totalBoxes, setTotalBoxes] = useState<number>(0); // Total number of boxes in the grid.
  const [colorStates, setColorStates] = useState<ColorState[]>([]); // Array holding color states for each box.

  /**
   * Maps color states to their corresponding color values.
   */
  const colorMap: { [key in ColorState]: string } = {
    0: "#000000", // Black
    1: "#1e3a8a", // Blue (bg-blue-800)
    2: "#F97316", // Orange (bg-orange-500)
  };

  /**
   * updateDimensions Function
   * -------------------------
   * Updates the grid's number of columns and rows based on the current window dimensions.
   * Sets the box size dynamically depending on the screen width for responsiveness.
   */
  const updateDimensions = () => {
    const newBoxSize = window.innerWidth <= 768 ? 50 : 75;
    setBoxSize(newBoxSize);

    const columns = Math.ceil(window.innerWidth / newBoxSize);
    const rows = Math.ceil(window.innerHeight / newBoxSize);
    const total = columns * rows;

    setGridColumns(columns);
    setGridRows(rows);
    setTotalBoxes(total);
    setColorStates(Array(total).fill(0)); // Initialize all boxes with black color.
  };

  /**
   * useEffect Hook - Grid Setup
   * ---------------------------
   * Initializes the grid dimensions and sets up an event listener to update them on window resize.
   */
  useEffect(() => {
    if (typeof window !== "undefined") {
      updateDimensions();
      window.addEventListener("resize", updateDimensions);

      return () => window.removeEventListener("resize", updateDimensions);
    }
  }, []);

  /**
   * useEffect Hook - Animate Color States
   * -------------------------------------
   * Animates the color states of the grid boxes at random intervals, 
   * cycling through black, blue, and orange. 
   * Cleans up the interval when the component is unmounted.
   */
  useEffect(() => {
    if (totalBoxes === 0) return; // Exit if grid size is not yet determined.

    const intervalId = setInterval(() => {
      const randomIndex = Math.floor(Math.random() * totalBoxes);
      setColorStates((prevColorStates) => {
        const newColorStates = [...prevColorStates];
        // Cycle color: 0 (black) -> 1 (blue) -> 2 (orange) -> 0 (black).
        newColorStates[randomIndex] = ((prevColorStates[randomIndex] + 1) % 3) as ColorState;
        return newColorStates;
      });
    }, 100); // Color change interval (milliseconds).

    return () => clearInterval(intervalId);
  }, [totalBoxes]);

  if (gridColumns === 0 || gridRows === 0) {
    return null; // Return null if grid dimensions are not set yet.
  }

  // Render the animated grid of boxes.
  return (
    <section
      aria-label="Animated background"
      className="inset-0 grid gap-2 opacity-70"
      style={{
        gridTemplateColumns: `repeat(${gridColumns}, ${boxSize}px)`,
        gridTemplateRows: `repeat(${gridRows}, ${boxSize}px)`,
      }}
    >
      {colorStates.map((colorState, index) => (
        <motion.div
          key={index}
          className="rounded-xl w-full h-full"
          animate={{ backgroundColor: colorMap[colorState] }}
          transition={{ duration: 0.5 }}
        />
      ))}
    </section>
  );
}

---
File Path: components/Toast.tsx
/**
 * File Path: components/Toast.tsx
 *
 * Toast Component
 * ---------------
 * This component is responsible for rendering toast notifications with animation effects.
 * It listens to the ToastContext for any updates and uses Framer Motion for smooth 
 * transitions when toasts appear or disappear. Toasts can be either success or error messages.
 */

"use client";

import React, { useContext } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext";

/**
 * Animation Variants
 * ------------------
 * Defines the animation states for toasts. Controls how the toasts will enter, 
 * behave, and exit the screen with specific motion patterns.
 */
const variants = {
  hidden: { y: "-100%", opacity: 0 },  // Hidden state, starting from above with no opacity.
  visible: { y: 0, opacity: 1 },       // Visible state, fully opaque and in position.
  exit: { y: "-100%", opacity: 0 },    // Exit state, moving up and fading out.
};

/**
 * Toast Component
 * ---------------
 * This functional component renders a list of toast notifications from the ToastContext.
 * Each toast is animated using framer-motion and can be dismissed by clicking the close button.
 * 
 * @returns {JSX.Element} The rendered Toast component containing toast notifications.
 */
const Toast: React.FC = (): JSX.Element => {
  // Access the toasts array and removeToast function from the ToastContext.
  const { toasts, removeToast } = useContext<ToastContextType>(ToastContext);

  return (
    <section className="fixed top-0 w-full z-50" aria-live="polite" aria-atomic="true">
      <AnimatePresence>
        {toasts.map((toast) => (
          <motion.div
            key={toast.id}  // Use a unique key for each toast notification.
            initial="hidden"
            animate="visible"
            exit="exit"
            variants={variants}  // Apply the animation variants.
            transition={{ duration: 0.5 }}  // Set the animation duration.
            className={`text-lg p-3 max-w-md m-auto rounded-lg shadow bg-opacity-90 mt-1 ${
              toast.messageType === "success"
                ? "shadow-green-900 bg-green-600 text-green-50"  // Styling for success toasts.
                : "shadow-red-900 bg-red-600 text-red-50"        // Styling for error toasts.
            }`}
          >
            <div className="p-3 grid grid-cols-[auto,1fr] gap-2 items-center font-extralight">
              <div className="flex-grow">{toast.message}</div>
              <button
                onClick={() => toast.id && removeToast(toast.id)}  // Remove the toast when the close button is clicked.
                className="justify-self-end"
                aria-label="Close notification"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  strokeWidth={1.5}
                  stroke="currentColor"
                  className="w-6 h-6"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="m9.75 9.75 4.5 4.5m0-4.5-4.5 4.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                  />
                </svg>
              </button>
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </section>
  );
};

export default Toast;

---
File Path: components/LessonForm.tsx
"use client";

/**
 * File Path: @/components/LessonForm.tsx
 *
 * LessonForm Component
 * --------------------
 * This component provides a form interface for creating or updating lesson entries.
 * The form includes fields for metadata such as type, title, documentation, code, slug, and links.
 * If a lesson ID is selected, the form dynamically loads the lesson for editing.
 * On successful operations, toast notifications are triggered and the user can return to the lesson list.
 */

import React, { useState, useContext, useEffect } from "react";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";
import { ToastContext, ToastContextType } from "@/contexts/ToastContext";

// Generate the Amplify client with the schema
const client = generateClient<Schema>();

/**
 * Props interface for the LessonForm component.
 */
interface LessonFormProps {
  /**
   * The ID of the selected lesson or null if no lesson is selected.
   */
  selectedLessonId: string | null;

  /**
   * A function to reset the current selection (e.g., after saving or deleting).
   */
  resetSelection: () => void;
}

/**
 * Interface for representing a link with text and URL.
 */
interface Link {
  text: string;
  url: string;
}

/**
 * LessonForm Component
 * --------------------
 * Renders a form for creating a new lesson or updating an existing one.
 * The form includes fields for type, title, documentation, code, slug, and links.
 * Users can save, update, or delete lessons.
 * 
 * @param {LessonFormProps} props - The props include the selected lesson ID and a reset function.
 * @returns {JSX.Element} The rendered form for lesson management.
 */
const LessonForm: React.FC<LessonFormProps> = ({ selectedLessonId, resetSelection }) => {
  // Form state for managing lesson properties
  const [type, setType] = useState<"setup" | "prereq" | "code">("setup");
  const [title, setTitle] = useState<string>("");
  const [docs, setDocs] = useState<string>("");
  const [code, setCode] = useState<string | undefined>(undefined);
  const [slug, setSlug] = useState<string>("");
  const [links, setLinks] = useState<Link[]>([{ text: "", url: "" }]);
  const { addToast } = useContext<ToastContextType>(ToastContext);

  useEffect(() => {
    if (selectedLessonId && selectedLessonId !== "new") {
      // Load the existing lesson for editing
      const fetchLesson = async () => {
        const { data, errors } = await client.models.LessonContent.get({
          id: selectedLessonId,
        });

        if (errors && errors.length > 0) {
          addToast({ messageType: "error", message: "Failed to load lesson." });
          console.error("Fetch lesson errors:", errors);
        } else if (data) {
          setType(data.type as "setup" | "prereq" | "code");
          setTitle(data.title);
          setDocs(data.docs);
          setCode(data.code || undefined);
          setSlug(data.slug);

          const cleanedLinks: Link[] = (data.links || [])
            .filter((link): link is NonNullable<typeof link> => link != null)
            .map((link) => ({
              text: link.text ?? "",
              url: link.url ?? "",
            }));

          setLinks(cleanedLinks.length > 0 ? cleanedLinks : [{ text: "", url: "" }]);
        }
      };

      fetchLesson();
    } else {
      // Clear form for new lesson creation
      setType("setup");
      setTitle("");
      setDocs("");
      setCode(undefined);
      setSlug("");
      setLinks([{ text: "", url: "" }]);
    }
  }, [selectedLessonId, addToast]);

  const handleSaveLesson = async () => {
    try {
      const formattedSlug = `${title
        .trim()
        .toLowerCase()
        .replace(/\//g, "-")
        .replace(/[^a-z0-9\s-]/g, "")
        .replace(/\s+/g, "-")
        .replace(/-+/g, "-")
        .replace(/^-|-$/g, "")}`;

      let result;
      setSlug(formattedSlug);

      if (selectedLessonId && selectedLessonId !== "new") {
        result = await client.models.LessonContent.update({
          id: selectedLessonId,
          type,
          title,
          docs,
          code,
          slug,
          links,
        });
      } else {
        result = await client.models.LessonContent.create({
          type,
          title,
          docs,
          code,
          slug: formattedSlug,
          links,
          isOrdered: false,
          orderIndex: null,
        });
      }

      if (result.errors && result.errors.length > 0) {
        addToast({ messageType: "error", message: "Failed to save lesson." });
        console.error("Save errors:", result.errors);
      } else {
        addToast({
          messageType: "success",
          message:
            selectedLessonId && selectedLessonId !== "new"
              ? "Lesson updated successfully!"
              : "Lesson created successfully!",
        });
        resetSelection();
      }
    } catch (error) {
      addToast({
        messageType: "error",
        message: "An unexpected error occurred.",
      });
      console.error("Save error:", error);
    }
  };

  const handleDeleteLesson = async () => {
    if (!selectedLessonId) return;

    const { errors } = await client.models.LessonContent.delete({
      id: selectedLessonId,
    });

    if (errors && errors.length > 0) {
      addToast({ messageType: "error", message: "Failed to delete lesson." });
      console.error("Delete errors:", errors);
    } else {
      addToast({
        messageType: "success",
        message: "Lesson deleted successfully!",
      });
      resetSelection();
    }
  };

  /**
   * Adds a new link field to the form.
   */
  const addLink = (): void => {
    setLinks([...links, { text: "", url: "" }]);
  };

  /**
   * Updates a link's text or URL based on the field type.
   *
   * @param {number} index - The index of the link to update.
   * @param {string} field - The field to update ("text" or "url").
   * @param {string} value - The new value for the specified field.
   */
  const handleLinkChange = (index: number, field: "text" | "url", value: string): void => {
    const updatedLinks = [...links];
    updatedLinks[index] = { ...updatedLinks[index], [field]: value };
    setLinks(updatedLinks);
  };

  /**
   * Removes a link from the form.
   *
   * @param {number} index - The index of the link to remove.
   */
  const removeLink = (index: number): void => {
    const updatedLinks = links.filter((_, i) => i !== index);
    setLinks(updatedLinks.length > 0 ? updatedLinks : [{ text: "", url: "" }]);
  };

  return (
    <section className="bg-black bg-opacity-70 rounded-lg w-full p-2" aria-labelledby="lesson-form-title">
      {/* Type Selection using Radio Buttons */}
      <header id="lesson-form-title" className="mb-4">
        <h2 className="block text-sm mb-2">Lesson Type</h2>
      </header>
      <div className="flex space-x-4 mb-4">
        <label className="flex items-center">
          <input
            type="radio"
            value="setup"
            checked={type === "setup"}
            onChange={() => setType("setup")}
            className="mr-2"
          />
          Setup
        </label>
        <label className="flex items-center">
          <input
            type="radio"
            value="prereq"
            checked={type === "prereq"}
            onChange={() => setType("prereq")}
            className="mr-2"
          />
          Prerequisite
        </label>
        <label className="flex items-center">
          <input
            type="radio"
            value="code"
            checked={type === "code"}
            onChange={() => setType("code")}
            className="mr-2"
          />
          Code
        </label>
      </div>

      {/* Title Input */}
      <div className="mb-4">
        <label className="block text-sm mb-2" htmlFor="lesson-title">Title</label>
        <input
          id="lesson-title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className="form-input"
          placeholder="Enter lesson title"
        />
      </div>

      {/* Documentation Input */}
      <div className="mb-4">
        <label className="block text-sm mb-2" htmlFor="lesson-docs">Documentation</label>
        <textarea
          id="lesson-docs"
          value={docs}
          onChange={(e) => setDocs(e.target.value)}
          className="form-input"
          placeholder="Enter documentation"
          rows={8}
        />
      </div>

      {/* Code Input (Optional) */}
      <div className="mb-4">
        <label className="block text-sm mb-2" htmlFor="lesson-code">Code (Optional)</label>
        <textarea
          id="lesson-code"
          value={code || ""}
          onChange={(e) => setCode(e.target.value)}
          className="form-input"
          placeholder="Enter code content"
          rows={8}
        />
      </div>

      {/* Links Section */}
      <div className="mb-6">
        <label className="block text-sm mb-2">Links</label>
        {links.map((link, index) => (
          <div key={index} className="flex items-center space-x-2">
            <input
              type="text"
              value={link.text}
              onChange={(e) => handleLinkChange(index, "text", e.target.value)}
              className="form-input w-1/2"
              placeholder="Link Text"
            />
            <input
              type="text"
              value={link.url}
              onChange={(e) => handleLinkChange(index, "url", e.target.value)}
              className="form-input w-1/2"
              placeholder="Link URL"
            />
            <button
              className="btn btn-secondary ml-2 mb-3"
              type="button"
              onClick={() => removeLink(index)}
            >
              Remove
            </button>
          </div>
        ))}
        <button className="btn btn-primary" type="button" onClick={addLink}>
          Add Link
        </button>
      </div>

      {/* Form Buttons */}
      <div className="flex justify-between">
        {selectedLessonId && selectedLessonId !== "new" ? (
          <>
            <button className="btn btn-secondary" onClick={handleDeleteLesson}>
              Delete
            </button>
            <div className="flex space-x-4">
              <button className="btn btn-secondary" onClick={resetSelection}>
                Cancel
              </button>
              <button className="btn btn-primary" onClick={handleSaveLesson}>
                Update Lesson
              </button>
            </div>
          </>
        ) : (
          <div className="flex space-x-4">
            <button className="btn btn-secondary" onClick={resetSelection}>
              Cancel
            </button>
            <button className="btn btn-primary" onClick={handleSaveLesson}>
              Save Lesson
            </button>
          </div>
        )}
      </div>
    </section>
  );
};

export default LessonForm;

---
File Path: components/CodeBlock.tsx
"use client";

import React, { useEffect, useRef } from "react";
import hljs from "highlight.js/lib/core";
import typescript from "highlight.js/lib/languages/typescript";
import "highlight.js/styles/github-dark.css"; // Syntax highlighting theme

/**
 * Props interface for the CodeBlock component.
 */
interface CodeBlockProps {
  /**
   * The code string to be highlighted.
   */
  code: string;

  /**
   * The programming language of the code, which determines the syntax highlighting rules.
   */
  language: string;
}

/**
 * CodeBlock Component
 * --------------------
 * Renders a block of code with syntax highlighting.
 * The component uses Highlight.js to apply syntax highlighting based on the specified programming language.
 * 
 * @param {CodeBlockProps} props - The component props containing the code and its language.
 * @returns {JSX.Element} The rendered code block with syntax highlighting.
 */
const CodeBlock: React.FC<CodeBlockProps> = ({ code, language }) => {
  const codeRef = useRef<HTMLElement>(null);

  // Register TypeScript language once during the component's first render
  useEffect(() => {
    hljs.registerLanguage("typescript", typescript);
  }, []);

  // Highlight the code block whenever the code or language changes
  useEffect(() => {
    if (codeRef.current) {
      hljs.highlightElement(codeRef.current);
    }
  }, [code, language]);

  return (
    <section className="p-1 bg-black" aria-label="Code block with syntax highlighting">
      <pre className="overflow-x-auto bg-gray-800 rounded-md">
        <code ref={codeRef} className={`language-${language}`}>
          {code}
        </code>
      </pre>
    </section>
  );
};

export default CodeBlock;

---
File Path: components/TableOfContents.tsx
"use client";

/**
 * File Path: @/components/TableOfContents.tsx
 *
 * TableOfContents Component
 * -------------------------
 * This component provides a slide-in table of contents (TOC) for navigating through a sorted list of lessons.
 * Users can toggle the visibility of the TOC, and it closes when a user clicks outside or selects a lesson link.
 * The component ensures accessibility, prevents body scrolling when open, and handles focus management.
 */

import React, { useState, useRef, useEffect } from "react";
import Link from "next/link";
import { motion, AnimatePresence } from "framer-motion";
import { XCircleIcon } from "@heroicons/react/24/solid";

/**
 * Interface representing a lesson object.
 */
interface Lesson {
  /**
   * The slug (URL-friendly identifier) for the lesson.
   */
  slug: string;

  /**
   * The title of the lesson.
   */
  title: string;
}

/**
 * Props interface for the TableOfContents component.
 */
interface TableOfContentsProps {
  /**
   * Array of lessons sorted in the desired order.
   */
  sortedLessonOrder: Lesson[];
}

/**
 * TableOfContents Component
 * -------------------------
 * This component renders a slide-in table of contents (TOC) panel that displays a list of lessons.
 * The user can toggle the TOC panel open or closed, and it automatically closes when the user
 * clicks outside of it or selects a lesson link. The TOC panel provides keyboard and screen reader
 * accessibility features and prevents scrolling while the TOC is open.
 *
 * @param {TableOfContentsProps} props - The component props containing a sorted list of lessons.
 * @returns {JSX.Element} The rendered table of contents with a toggle button and interactive lesson links.
 */
const TableOfContents: React.FC<TableOfContentsProps> = ({ sortedLessonOrder }) => {
  const [isOpen, setIsOpen] = useState(false); // State to track the open/closed state of the TOC.
  const tocRef = useRef<HTMLDivElement>(null); // Reference to the TOC panel.
  const buttonRef = useRef<HTMLButtonElement>(null); // Reference to the toggle button.

  /**
   * Toggles the TOC panel open or closed.
   */
  const toggleOpen = () => setIsOpen((prev) => !prev);

  /**
   * Closes the TOC if a click occurs outside the panel.
   * 
   * @param {MouseEvent} event - The click event.
   */
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        tocRef.current &&
        !tocRef.current.contains(event.target as Node) &&
        buttonRef.current &&
        !buttonRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      // Prevent scrolling when TOC is open
      document.body.style.overflow = "hidden";
    } else {
      document.removeEventListener("mousedown", handleClickOutside);
      // Restore scrolling when TOC is closed
      document.body.style.overflow = "auto";
    }

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.body.style.overflow = "auto";
    };
  }, [isOpen]);

  /**
   * Handles closing the TOC when a link is clicked and returns focus to the toggle button.
   */
  const handleLinkClick = () => {
    setIsOpen(false);
    buttonRef.current?.focus(); // Return focus to the toggle button after closing the TOC.
  };

  return (
    <>
      {/* Toggle Button */}
      <button
        ref={buttonRef}
        onClick={toggleOpen}
        className="fixed w-16 md:w-28 top-16 md:top-16 left-0 z-0 text-white bg-black bg-opacity-50 p-1 py-2 border-r border-b border-t border-white text-xs rounded-tr-lg rounded-br-lg"
        aria-label={isOpen ? "Close Table of Contents" : "Show Table of Contents"}
        aria-expanded={isOpen}
        aria-controls="toc-panel"
      >
        {isOpen ? "" : "Table of Contents"}
      </button>

      {/* Overlay */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            key="overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 0.5 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="fixed inset-0 bg-black z-30"
          />
        )}
      </AnimatePresence>

      {/* Table of Contents Panel */}
      <AnimatePresence>
        {isOpen && (
          <motion.aside
            key="toc-panel"
            id="toc-panel"
            initial={{ x: "-100%" }}
            animate={{ x: 0 }}
            exit={{ x: "-100%" }}
            transition={{ type: "tween", duration: 0.3 }}
            className="fixed z-40 top-0 left-0 h-full w-full max-w-md bg-gradient-to-br from-black to-slate-950 shadow-lg overflow-y-auto"
            ref={tocRef}
            aria-labelledby="toc-title"
          >
            {/* Header Inside TOC */}
            <header className="flex justify-between items-center p-4 border-b">
              <h2 id="toc-title" className="text-lg font-extralight">
                Table of Contents
              </h2>
              {/* Close Button Inside TOC */}
              <button
                onClick={toggleOpen}
                className="text-blue-600 hover:text-blue-800 focus:outline-none"
                aria-label="Close Table of Contents"
              >
                <XCircleIcon className="size-8 text-white" />
              </button>
            </header>

            {/* TOC Links */}
            <nav className="p-4 text-left">
              <ul>
                {sortedLessonOrder.map((lesson) => (
                  <li key={lesson.slug} className="mb-3">
                    <Link
                      href={`/members/code/${lesson.slug}`}
                      onClick={handleLinkClick}
                      className="text-white text-sm hover:underline"
                    >
                      {lesson.title}
                    </Link>
                  </li>
                ))}
              </ul>
            </nav>
          </motion.aside>
        )}
      </AnimatePresence>
    </>
  );
};

export default TableOfContents;

---
File Path: contexts/ToastContext.tsx
'use client';

/**
 * File Path: contexts/ToastContext.tsx
 * 
 * ToastContext
 * ------------
 * This file provides a React context for managing toast notifications throughout the application.
 * Components can trigger toast messages for success and error notifications, with support for 
 * automatic timeout and removal of toasts.
 */

import React, { createContext, useState, useCallback, ReactNode } from 'react';
import { v4 as uuidv4 } from 'uuid';

/**
 * Toast Interface
 * ---------------
 * Defines the structure of a toast notification object.
 * 
 * @interface Toast
 * @property {string} [id] - Optional unique identifier. If not provided, one will be generated.
 * @property {'success' | 'error'} messageType - Type of message, either 'success' or 'error'.
 * @property {string} message - The text content of the toast message.
 * @property {number} [duration] - Optional duration in milliseconds after which the toast will automatically disappear.
 */
interface Toast {
  id?: string;
  messageType: 'success' | 'error';
  message: string;
  duration?: number;
}

/**
 * ToastContextType Interface
 * --------------------------
 * Defines the shape of the context's value, specifying what can be accessed or performed.
 * 
 * @interface ToastContextType
 * @property {Toast[]} toasts - Array of current toast messages being displayed.
 * @property {(toast: Toast) => void} addToast - Function to add a new toast to the display queue.
 * @property {(id: string) => void} removeToast - Function to remove a specific toast by ID.
 */
export interface ToastContextType {
  toasts: Toast[];
  addToast: (toast: Toast) => void;
  removeToast: (id: string) => void;
}

// Initializing the context with default empty implementations to prevent null checks.
const defaultContextValue: ToastContextType = {
  toasts: [],
  addToast: () => {}, // Empty function placeholder.
  removeToast: () => {} // Empty function placeholder.
};

// Creating the ToastContext with the default value.
export const ToastContext = createContext<ToastContextType>(defaultContextValue);

/**
 * ToastProviderProps Interface
 * ----------------------------
 * Defines the structure for the props passed to the ToastProvider component.
 * 
 * @interface ToastProviderProps
 * @property {ReactNode} children - Accepts any valid React children.
 */
interface ToastProviderProps {
  children: ReactNode;
}

/**
 * ToastProvider Component
 * -----------------------
 * Provides the ToastContext to all children components, allowing them to trigger
 * and manage toast notifications.
 * 
 * @component
 * @param {ToastProviderProps} props - The component props.
 * @returns {JSX.Element} The rendered ToastProvider component.
 */
export const ToastProvider: React.FC<ToastProviderProps> = ({ children }) => {
  const [toasts, setToasts] = useState<Toast[]>([]); // State to track the current toasts.

  /**
   * removeToast Function
   * --------------------
   * Removes a toast notification from the list based on its ID.
   * 
   * @param {string} id - The ID of the toast to be removed.
   */
  const removeToast = useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  /**
   * addToast Function
   * -----------------
   * Adds a new toast to the array of toasts and schedules its automatic removal.
   * 
   * @param {Toast} toast - The toast object to add.
   */
  const addToast = useCallback((toast: Toast) => {
    const toastWithDefaultId = { ...toast, id: toast.id || uuidv4() }; // Assign a default ID if not provided.
    setToasts((prevToasts) => [...prevToasts, toastWithDefaultId]); // Append the new toast to the array.

    const duration = toast.duration || 3000; // Default to 3000ms if no duration is provided.
    setTimeout(() => {
      removeToast(toastWithDefaultId.id!); // Remove toast after duration.
    }, duration);
  }, [removeToast]);

  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
      {children}
    </ToastContext.Provider>
  );
};

---
File Path: contexts/AuthContext.tsx
"use client";

/**
 * File Path: contexts/AuthContext.tsx
 * 
 * AuthContext
 * -----------
 * This file provides a React context for managing authentication throughout the application.
 * It uses AWS Amplify for authentication functionalities and allows components to access
 * authentication status, user information, admin privileges, and user profile details. It also handles user sign-out.
 */

import React, { createContext, useContext, ReactNode, useState, useEffect } from "react";
import { AuthUser, fetchAuthSession } from "@aws-amplify/auth";

/**
 * UserProfile Interface
 * ---------------------
 * Defines the structure of the user profile object containing essential user information.
 * 
 * @interface UserProfile
 * @property {string} firstName - The user's first name.
 * @property {string} lastName - The user's last name.
 * @property {string} emailAddress - The user's email address.
 * @property {string} username - The user's preferred username.
 */
interface UserProfile {
  firstName: string;
  lastName: string;
  emailAddress: string;
  username: string;
}

/**
 * AuthContextProps Interface
 * --------------------------
 * Defines the shape of the authentication context value, providing access to user info,
 * sign-out functionality, admin status, loading state, and user profile.
 * 
 * @interface AuthContextProps
 * @property {AuthUser | null | undefined} user - The currently authenticated user, null if not authenticated.
 * @property {() => void} signOut - Function to handle user sign-out.
 * @property {boolean} isAdmin - Indicates if the authenticated user belongs to the "admin" group.
 * @property {boolean} loading - Indicates if the process of determining admin status is ongoing.
 * @property {UserProfile | null} profile - The authenticated user's profile information.
 */
export interface AuthContextProps {
  user: AuthUser | null | undefined;
  signOut: () => void;
  isAdmin: boolean;
  loading: boolean;
  profile: UserProfile | null;
}

// Creating the AuthContext with an initial default value to avoid null checks and ensure type safety.
const AuthContext = createContext<AuthContextProps | null>(null);

/**
 * useAuth Hook
 * ------------
 * Custom hook to provide easy access to the authentication context.
 * Throws an error if used outside of an `AuthProvider`, ensuring proper usage.
 * 
 * @returns {AuthContextProps} The authentication context properties, including user info, admin status, sign-out function, and user profile.
 */
export const useAuth = (): AuthContextProps => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider to access authentication functionalities.");
  }
  return context;
};

/**
 * AuthProviderProps Interface
 * ---------------------------
 * Defines the props accepted by the `AuthProvider` component, which wraps its children 
 * with the authentication context and provides necessary authentication data and methods.
 * 
 * @interface AuthProviderProps
 * @property {ReactNode} children - The nested child components that consume authentication context.
 * @property {AuthUser | null} user - The currently authenticated user.
 * @property {() => void} signOut - Function to handle user sign-out.
 */
interface AuthProviderProps {
  children: ReactNode;
  user: AuthUser | null;
  signOut: () => void;
}

/**
 * AuthProvider Component
 * ----------------------
 * Wraps all child components that require access to the authentication context.
 * Provides context values such as the authenticated user, sign-out function, admin status, and user profile.
 * 
 * @component
 * @param {AuthProviderProps} props - The component props.
 * @returns {JSX.Element} The rendered AuthProvider component, making authentication context accessible to all children.
 */
export const AuthProvider: React.FC<AuthProviderProps> = ({ children, user, signOut }) => {
  const [isAdmin, setIsAdmin] = useState<boolean>(false); // State to track admin privileges.
  const [loading, setLoading] = useState<boolean>(true); // State to track the loading status of admin checks.
  const [profile, setProfile] = useState<UserProfile | null>(null); // State to store the user's profile information.

  useEffect(() => {
    /**
     * checkAdminStatus Function
     * -------------------------
     * Checks if the authenticated user belongs to the "admin" group by fetching their session
     * and examining the token payload. Extracts and sets the user's profile information.
     */
    async function checkAdminStatus() {
      if (user) {
        try {
          const session = await fetchAuthSession();
          const idTokenPayload = session.tokens?.idToken?.payload;

          if (idTokenPayload) {
            const groupsRaw = idTokenPayload["cognito:groups"];
            let groups: string[] | undefined;

            if (Array.isArray(groupsRaw) && groupsRaw.every(item => typeof item === "string")) {
              groups = groupsRaw;
            }

            setIsAdmin(Array.isArray(groups) && groups.includes("admin"));

            const extractedProfile: UserProfile = {
              firstName: typeof idTokenPayload.given_name === "string" ? idTokenPayload.given_name : "",
              lastName: typeof idTokenPayload.family_name === "string" ? idTokenPayload.family_name : "",
              emailAddress: typeof idTokenPayload.email === "string" ? idTokenPayload.email : "",
              username: typeof idTokenPayload.preferred_username === "string" ? idTokenPayload.preferred_username : ""
            };

            setProfile(extractedProfile);
          } else {
            setProfile(null);
          }
        } catch (error) {
          console.error("Failed to fetch user session:", error);
          setIsAdmin(false);
          setProfile(null);
        } finally {
          setLoading(false);
        }
      } else {
        setIsAdmin(false);
        setProfile(null);
        setLoading(false);
      }
    }

    checkAdminStatus();
  }, [user]);

  return (
    <AuthContext.Provider value={{ user, signOut, isAdmin, loading, profile }}>
      {children}
    </AuthContext.Provider>
  );
};

---
File Path: types/LessonContent.ts
// File Path: types/LessonContent.ts

/**
 * Link Interface
 * --------------
 * Represents a link object with its display text and URL.
 */
export interface Link {
  text: string; // The display text for the link
  url: string;  // The URL for the link
}

/**
 * LessonContent Interface
 * -----------------------
 * Represents the structure of a lesson, including metadata such as title, slug, code, docs,
 * ordering information, and a list of related links.
 */
export interface LessonContent {
  id: string;
  title: string;
  slug: string;
  code: string | null;
  docs: string;
  isOrdered: boolean;
  orderIndex: number | null;
  links: Link[]; // An array of links related to the lesson
}

---
File Path: utils/amplifyServerUtils.ts
// @/utils/amplifyServerUtils.ts

/**
 * This file provides utility functions for server-side operations using AWS Amplify
 * with Next.js. It includes functions for managing server-side authentication
 * using cookies and for retrieving the currently authenticated user.
 */

import { cookies } from 'next/headers';
import { createServerRunner } from '@aws-amplify/adapter-nextjs';
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/api';
import { getCurrentUser } from 'aws-amplify/auth/server';
import { type Schema } from '@/amplify/data/resource';
import outputs from '@/amplify_outputs.json';

/**
 * Creates a server runner with the Amplify configuration.
 * This function enables running server-side operations within the Amplify context.
 * The configuration is derived from the `outputs` file generated by AWS Amplify.
 */
export const { runWithAmplifyServerContext } = createServerRunner({
  config: outputs,
});

/**
 * Generates a server-side Amplify client that uses cookies for authentication.
 * This client allows authenticated API requests from the server, using the provided cookies
 * to maintain user sessions.
 */
export const cookiesClient = generateServerClientUsingCookies<Schema>({
  config: outputs,
  cookies,
});

/**
 * AuthGetCurrentUserServer
 * ------------------------
 * Retrieves the currently authenticated user on the server by executing a server-side
 * operation in the Amplify context. If the user is authenticated, their details are returned.
 * If an error occurs or the user is not authenticated, it returns `null`.
 *
 * @async
 * @returns {Promise<any | null>} - Returns the current authenticated user object if available, otherwise `null`.
 */
export async function AuthGetCurrentUserServer() {
  try {
    const currentUser = await runWithAmplifyServerContext({
      nextServerContext: { cookies },
      operation: (contextSpec) => getCurrentUser(contextSpec),
    });
    return currentUser;
  } catch (error) {
    console.error('Error retrieving the current user:', error);
    return null;
  }
}

---